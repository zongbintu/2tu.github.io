[{"title":"DataBinding setDrawable 无法显示的问题","url":"/2015/10/14/DataBinding-setDrawable/","content":"\n问题：dataBinding中drawableLeft无效\n\n解决办法：采用传统代码设置\n\n思路：\n\n\n1、使用代码设置Drawable有两种方式。drawable.setBounds(int,int,int,int);//未设置则不显示view.setCompoundDrawables(drawable,null,null,null);\nview.setCompoundDrawablesWithIntrinsicBounds(drawable,null,null,null);2、查看生成的binding代码发现采用setCompoundDrawables方式，且未设置Bounds\n\n使用到的代码android:drawableRight=”@{1==employee.state ?@drawable/ic_job : @drawable/ic_job_quit}”\n\nTextViewBindingAdapter\n@BindingAdapter({&quot;android:drawableRight&quot;})\npublic static void setDrawableRight(TextView view, Drawable drawable) {\n    Drawable[] drawables = view.getCompoundDrawables();\n    view.setCompoundDrawables(drawables[0], drawables[1], drawable, drawables[3]);\n}\n\n资料https://code.google.com/p/android-developer-preview/issues/detail?id=3175&amp;can=1&amp;q=status%3Afixed%20and%20opened-after%3A2015%2F4%2F1&amp;sort=-opened&amp;colspec=ID%20Type%20Status%20Owner%20Summary%20Opened*\n\n","categories":["Android"],"tags":["DataBinding"]},{"title":"如何找到导致fullgc的问题代码","url":"/2023/05/28/How-to-find-the-code-that-fullgc/","content":"服务频繁fullgc无法对外提供服务。需要查看分析出是大对象？内存分配不合理还是造成了内存泄漏的问题。查找步骤\n\n查看，确认gc情况\n查看jvm运行参数\n\ndump分析\n\n找出问题代码\n\n查看存活对象情况\n\n查看该进程下占用CPU最高的线程\n\n查看，确认gc情况jstat -gc [pid] 2000\n每2秒打印一次pid的gc情况\n\n查看jvm运行参数jinfo -flags [pid]\ndump分析jmap -dump:live,format=b,file=[filename].hporf [pid]\n使用MAT分析内存情况\n查看对象Histogram\n大对象Dominator Tree\n","categories":["Java"],"tags":["fullgc"]},{"title":"DownloadManager not work","url":"/2015/11/25/DownloadManager-notification/","content":"问题：有用户反映点击版本升级后无响应(采用的DownloadManager)思路：“应用程序管理”-&gt;“下载管理器”-&gt;“启用”，再点击“升级”，一切OK。但是不完美，所以我们需要检查是否启用，未启用则引导设置。解决办法：直接引用封装好的UpgradeLibrary,点我\n代码片断判断是否启用，未启用则弹出框让用户选择开启\npublic final class DownloadManagerResolver {\n\nprivate static final String DOWNLOAD_MANAGER_PACKAGE_NAME = &quot;com.android.providers.downloads&quot;;\n\n/**\n * Resolve whether the DownloadManager is enable in current devices.\n *\n * @return true if DownloadManager is enable,false otherwise.\n */\npublic static boolean resolve(Context context) {\n    boolean enable = resolveEnable(context);\n    if (!enable) {\n        AlertDialog alertDialog = createDialog(context);\n        alertDialog.show();\n    }\n    return enable;\n}\n\n/**\n * Resolve whether the DownloadManager is enable in current devices.\n *\n * @param context\n * @return true if DownloadManager is enable,false otherwise.\n */\nprivate static boolean resolveEnable(Context context) {\n    int state = context.getPackageManager()\n            .getApplicationEnabledSetting(DOWNLOAD_MANAGER_PACKAGE_NAME);\n\n    if (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.JELLY_BEAN_MR2) {\n        return !(state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED ||\n                state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER\n                || state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED);\n    } else {\n        return !(state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED ||\n                state == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_USER);\n    }\n}\n\nprivate static AlertDialog createDialog(final Context context) {\n    TextView messageTextView = new TextView(context);\n    messageTextView.setTextSize(16f);\n    messageTextView.setText(R.string.downloadmanger_enable);\n    return new AlertDialog.Builder(context)\n            .setView(messageTextView)\n            .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {\n                @Override\n                public void onClick(DialogInterface dialog, int which) {\n                    enableDownloadManager(context);\n                }\n            })\n            .setCancelable(false)\n            .create();\n}\n\n/**\n * Start activity to Settings to enable DownloadManager.\n */\nprivate static void enableDownloadManager(Context context) {\n    try {\n        //Open the specific App Info page:\n        Intent intent = new Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS);\n        intent.setData(Uri.parse(&quot;package:&quot; + DOWNLOAD_MANAGER_PACKAGE_NAME));\n        context.startActivity(intent);\n    } catch (ActivityNotFoundException e) {\n        e.printStackTrace();\n\n        //Open the generic Apps page:\n        Intent intent = new Intent(android.provider.Settings.ACTION_MANAGE_APPLICATIONS_SETTINGS);\n        context.startActivity(intent);\n    }\n}\n}    \n问题解决。类文件：DownloadManagerResolver.java\n参考：http://www.samsung.com/hk_en/support/skp/htg/17649#nonehttp://stackoverflow.com/questions/21551538/how-to-enable-android-download-manager\n","categories":["Android"],"tags":["DownloadManager"]},{"title":"Jenkins构建Android、IOS并上传到蒲公英","url":"/2015/12/23/JenkinsContinuousImprovement/","content":"前言作为产品级的外包，常常会出现fix一个bug要更新十几甚至几十个产品（打包上传）。作为程序猿看到这种需求时，第一想法就是“是时候找办法偷懒了”。虽然Android以前采用Ant打包构建，现在与时俱进采用Gradle打包所有产品，然后再上传。IOS也可以采用命令行的方式做到。但是为了实现傻瓜式，可视化，同时兼容Android、IOS的方式，采用Jenkins实现很有必要。  \n实现步骤1、下载安装Jenkins2、配置Jenkins安装插件3、创建Job实现构建4、上传至蒲公英  \n我的环境MacJDK 1.7Gradle 2.8IOS 8.0Jenkins 1.641   \n一、下载安装Jenkins在Jenkins下载war包运行java -jar jenkins.war –httpPort=8888，提示”信息: Jenkins is fully up and running”，表示启动成功打开“http://localhost:8888/”\n二、配置Jenkins安装插件1、安装插件系统管理-》插件管理-》可选插件-》过滤-》输入名称安装Git pluginMultiple SCMs plugin（针对多分支或多Git地址的情况，Git Plugin不能实现）Ftp plugin(FTP上传)Publish Over SSH(SFTP上传)Gradle pluginXcode plugin  \n2、配置1）Gradle相关配置，添加GRADLE____HOME环境变量或系统管理-》系统设置-》Gradle安装，选择Gradle目录2）SFTP相关配置3）ANDROID____HOME环境变量添加，否则要报“SDK location not found”。或者为Android项目添加“local.properties”文件，我们当然选择配置环境变量\n3、创建JOB创建JOB的几个问题1）Multiple SCMs时注意选择subdirectory2）Android 包Gradle3)IOS 配置选择Target及Xcode Project File选择Pack application and build .ipa的时候，证书要选择正确。我在打包时出现首先匹配的是*的证书。删除*证书后就出现匹配不到证书的情况。最后解决办法是在Build Settings里面配置Release的证书，如图  \n4、上传至蒲公英 执行下列命令上传filen=`find . -name release.apk`;curl -F “file=@$filen” -F “uKey=4602339dac5705c81578cd8580505ab5” -F “_api_key=e3d6725adc24fce33c5210271ef1efed” http://www.pgyer.com/apiv1/app/upload   \n后记上传到蒲公英只作为测试使用。正式分发产品时会更新到自己的网站上，并更新数据库，旧有的包备份等一套应用。目前采用的.net + php。发现并不能通用，后续希望改为shell + php\n参考http://www.itnose.net/detail/6075531.htmlhttp://blog.csdn.net/guojin08/article/details/39026795http://www.android100.org/html/201506/22/156680.htmlhttps://wiki.jenkins-ci.org/display/JENKINS/Publish+Over+SSH+Plugin  \n","categories":["Other"],"tags":["Jenkins","iOS"]},{"title":"module自动适应app中的flavors","url":"/2015/12/11/ModuleFlavors/","content":"\n需求  \n\napp进行分层设计，将业务层剥离至module中  \n\n问题  \nmodule自动适应app中的flavors打包时自动匹配\n解决办法  \napp与module使用相同的flavors配置module中build.gradle添加“publishNonDefault true”app中添加module flavor compile  \nlocalCompile project(path: &#39;:mylibrary&#39;, configuration: &#39;localRelease&#39;)productionCompile project(path: &#39;:mylibrary&#39;, configuration: &#39;productionRelease&#39;)compile project(&#39;:mylibrary&#39;)\n\n示例app build.gradlemodule build.gradle工程\n\n参考  \n\n\nhttp://stackoverflow.com/questions/24860659/multi-flavor-app-based-on-multi-flavor-library-in-android-gradlehttp://stackoverflow.com/questions/24307596/how-can-i-add-flavors-in-a-module-with-android-studiohttp://stackoverflow.com/questions/27519128/android-studio-build-variation-module-selection\n","categories":["Android"],"tags":["module","flavor"]},{"title":"NODE_ENV跨平台设置","url":"/2018/01/18/NODE-ENV-cross/","content":"set NODE_ENV问题最近接手系统中采用React作为管理端，其中有这样一句\n\"build\": \"node ./tools/gulpfile.js&amp;&amp;set NODE_ENV=__PROD__&amp;&amp;node ./tools/webpack.config.js\"\n其中“set NODE_ENV=PROD”却未在我的Mac下生效，其他成员使用Windows。原因是Windows下使用set NODE_ENV=xx，Unix下应该为export NODE_ENV=xx，于是不得不区分操作系统进行设置，于是就有了cross-env这个方案。\n使用cross-env解决跨平台修改命令为\n\"build\": \"node ./tools/gulpfile.js&amp;&amp;cross-env NODE_ENV=__PROD__&amp;&amp;node ./tools/webpack.config.js\"\n执行后，结果还是TMD没生效。查看cross-env的Usage后，区别在于我使用了&amp;&amp;分隔，在后面的webpack.config.js中获取前面设置的NODE_ENV，问题是否出在这里呢？\n&amp;&amp;与空格问题感谢justjavac提供支持  \n&amp;&amp;为shell逻辑与运算符格式command1 &amp;&amp; command2 [&amp;&amp; command3 …]command1执行成功才会执行command2，任意命令执行失败则不会再执行后面的命令shell执行命令可以(;、&amp;&amp;、||）间隔\n正确使用 cross-env vs cross-evn-shellcross-env\"build\": \"node ./tools/gulpfile.js&amp;&amp;cross-env NODE_ENV=__PROD__ node ./tools/webpack.config.js\"\ncross-env-shell\"build\": \"node ./tools/gulpfile.js&amp;&amp;cross-env-shell NODE_ENV=__PROD__ \\\"node ./tools/webpack.config.js &amp;&amp; echo $NODE_ENV\\\"\"\\”\\”包裹中的内容都可以有效取到cross-env-shell设置的环境变量，这里面的原理在于Node本身的跨平台机制spawn\n参考cross-env 不起作用怎么办？\n","categories":["Web"],"tags":["NODE_ENV","cross-env","spawn"]},{"title":"Gradle 2.4之后使用JitPack发布Github开源库","url":"/2015/11/16/JitPack/","content":"之前采用过jcenter发布，各种步骤非常麻烦。在“掘金”上看到一篇文章可采用JitPack一键发布，照着抄遇到了一点坑。待此记录。原作者的文章地址“http://www.dss886.com/android/2015/10/17/16-23/”\n一、配置并提交到GithubGradleTo enable installing into local maven repository and JitPack you need to add the android-maven plugin.\nIf using Gradle 2.4 or later:Gradle 2.4之后要添加如下配置\n1) In your root build.gradle:root/build.gradle添加buildscript &#123;     dependencies &#123;        classpath 'com.github.dcendents:android-maven-gradle-plugin:2.0' // Add this line \n2) Add the following lines to your library/build.gradle:library/build.gradle添加apply plugin: 'com.github.dcendents.android-maven'   group='com.github.YourUsername'\n二、获取JitPack中依赖地址打开https://jitpack.io/输入Github地址点击“Look up”点击“Get it”查看Log\n1）在项目中引用root/build.gradleallprojects &#123;      repositories &#123;          jcenter()          maven &#123; url \"https://jitpack.io\" &#125;     &#125;  &#125;\n2）添加依赖dependencies {  \n    compile &apos;com.github.username:Project-name:v1.0&apos;\n}\n 一切OK。项目中也可以引用，不用再引用AAR。\n 目前（2016-8-31）JitPack默认采用gradle2.7，可以采用wrapper方式使用指定Gradle版本。 另外也支持module，详情见下方参考文档。\n 参考：https://jitpack.io/docs/ANDROID/ https://jitpack.io/docs/BUILDING/#multi-module-projects http://www.dss886.com/android/2015/10/17/16-23/\n","categories":["Other"],"tags":["Gradle","JitPack"]},{"title":"ThreadPoolExecutor学习","url":"/2023/04/07/ThreadPoolExecutor/","content":"\n创建线程的几种方式\nThread\nRunnable\nCallable（配合Future获取返回值）\n线程池\nExecutors\nThreadPoolExecutor\n\n\n\n\n线程池ThreadPoolExcecutor的7个参数/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the *        pool * @param keepAliveTime when the number of threads is greater than *        the core, this is the maximum time that excess idle threads *        will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are *        executed.  This queue will hold only the &#123;@code Runnable&#125; *        tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor *        creates a new thread * @param handler the handler to use when execution is blocked *        because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; *         &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; *         &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize,                          int maximumPoolSize,                          long keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler handler)\n\ncorePoolSize（核心线程数）\nmaximumPoolSize（最大线程数）\nkeepAliveTime、unit（最大空闲时间）\nworkQueue（阻塞队列）\nthreadFactory（线程工厂，为线程自定义名称）\nhandler（拒绝策略）\n\n\n线程池执行流程\n\n线程池属性标识   /**    * The main pool control state, ctl, is an atomic integer packing    * two conceptual fields    *   workerCount, indicating the effective number of threads    *   runState,    indicating whether running, shutting down etc    *    * In order to pack them into one int, we limit workerCount to    * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2    * billion) otherwise representable. If this is ever an issue in    * the future, the variable can be changed to be an AtomicLong,    * and the shift/mask constants below adjusted. But until the need    * arises, this code is a bit faster and simpler using an int.    *    * The workerCount is the number of workers that have been    * permitted to start and not permitted to stop.  The value may be    * transiently different from the actual number of live threads,    * for example when a ThreadFactory fails to create a thread when    * asked, and when exiting threads are still performing    * bookkeeping before terminating. The user-visible pool size is    * reported as the current size of the workers set.    *    * The runState provides the main lifecycle control, taking on values:    *    *   RUNNING:  Accept new tasks and process queued tasks    *   SHUTDOWN: Don't accept new tasks, but process queued tasks    *   STOP:     Don't accept new tasks, don't process queued tasks,    *             and interrupt in-progress tasks    *   TIDYING:  All tasks have terminated, workerCount is zero,    *             the thread transitioning to state TIDYING    *             will run the terminated() hook method    *   TERMINATED: terminated() has completed    *    * The numerical order among these values matters, to allow    * ordered comparisons. The runState monotonically increases over    * time, but need not hit each state. The transitions are:    *    * RUNNING -&gt; SHUTDOWN    *    On invocation of shutdown(), perhaps implicitly in finalize()    * (RUNNING or SHUTDOWN) -&gt; STOP    *    On invocation of shutdownNow()    * SHUTDOWN -&gt; TIDYING    *    When both queue and pool are empty    * STOP -&gt; TIDYING    *    When pool is empty    * TIDYING -&gt; TERMINATED    *    When the terminated() hook method has completed    *    * Threads waiting in awaitTermination() will return when the    * state reaches TERMINATED.    *    * Detecting the transition from SHUTDOWN to TIDYING is less    * straightforward than you'd like because the queue may become    * empty after non-empty and vice versa during SHUTDOWN state, but    * we can only terminate if, after seeing that it is empty, we see    * that workerCount is 0 (which sometimes entails a recheck -- see    * below).    */    // 1.高3位：声明当前线程池状态  2.低29位：声明线程池中的线程个数   private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));   // 29，方便后面做位运算   private static final int COUNT_BITS = Integer.SIZE - 3;   // 通过位运算得出最大容量   private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;// 线程池状态   // runState is stored in the high-order bits   // 111 正常接收任务   private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;   // 000 不接收新任务，仍会处理阻塞队列中的任务，正在进行中的任务也正常进行   private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;   // 001 不接收新任务，不处理阻塞队列中的任务，中断正在进行中的任务   private static final int STOP       =  1 &lt;&lt; COUNT_BITS;   // 010 过渡状态，当前线程池即将结束   private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;   // 011 结束   private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;   // Packing and unpacking ctl   // 获取线程池状态   private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;   // 获取线程池的线程数量   private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;   private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;\n\n\n线程池数量选择\nIO密集型（I/O bound）程序处理时，CPU需要等待时间比CPU运算时间更多。线程数量：（线程等待时间+CPU运算时间）* CPU核数 / CPU处理时间\nCPU密集型（CPU-bound）也叫计算密集型，大部分时间用来计算、逻辑判断等CPU动作的程序。任务不太需要访问I/O，或使用线程等方式减少了IO等待时间。线程数量：CPU个数或+1 +2\n\nnginx IO密集型nginx处理文件缓冲时有几种方式\n\nsendfile处理小文件时使用\n减少数据拷贝，提高发送效率\nsocket通过dma直接访问文件数据\n\n\ndirectio处理大文件时使用\ndirectio以512字节为边界对齐block进行发送\n未对齐的block以阻塞方式读取发送\n\n\naio\nairead\n线程池异步读取较大文件，以提高io效率\n\n\n\nredis CPU密集型io-threads = 4非阻塞IO多路复用\nIO线程作用于这就要看其中read、send中的线程等待时间多，还是decode、encode使用CPU运算时间多。由于我们使用非阻塞IO，无需等待，所以decode、encode时CPU运算时间多，最后得出结论Redis是 CPU密集型\n","categories":["Java"],"tags":["ThreadPoolExecutor"]},{"title":"Activity调用外部为WebView设值不成功问题解决","url":"/2017/12/15/WebView-RestoreInstance-onActivityForResult-not-work/","content":"简单的Android保存恢复数据，有很多app没有做到。如之前提到的知名APP掘金v3.1.1，以及朋友公司的书香云集v5.40.1，基本每去一家公司都会要为公司产品检查修改此类问题。本以为自己是这方面的老司机，没想到最近同事反馈上来又有此类问题发生，而这次的问题却是与我有关。16年9月开始负责重构马上金融2.0，其中一项重要功能是hybrid资料表单以适应风控频繁变化的需求。采用jsbridge动态写入js解决js与native相互调用的安全性，此次按下不表。问题发生在表单中js调用android访问联系人，获取联系人数据调用js设置时不成功  \n原因还原代码MainActivity  implements RestoreActivityResultCallback\n @Override protected void onCreate(Bundle savedInstanceState) &#123;   super.onCreate(savedInstanceState);...   webView.setWebViewClient(new WebViewClient() &#123;     @Override public void onPageFinished(WebView view, String url) &#123;       super.onPageFinished(view, url);       webView.onPageFinished(view, url);     &#125;   &#125;);   webView.addJavascriptInterface(new JSInteraction(), \"contact\");   if (savedInstanceState != null) &#123;     webView.restoreState(savedInstanceState);   &#125; else &#123;     webView.loadUrl(url);   &#125; &#125;  @Override protected void onSaveInstanceState(Bundle outState) &#123;   super.onSaveInstanceState(outState);   webView.saveState(outState); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;   super.onActivityResult(requestCode, resultCode, data);   if (requestCode == REQUEST_CODE_PICK_CONTACT) &#123;     webView.onActivityResult(requestCode, resultCode, data);     if (Activity.RESULT_OK == resultCode &amp;&amp; data != null) &#123;       setContact(data);     &#125;   &#125; &#125; @Override public void restoreActivityResult(int requestCode, int resultCode, Intent data) &#123;   if (requestCode == REQUEST_CODE_PICK_CONTACT &amp;&amp; RESULT_OK == resultCode) &#123;     setContact(data);   &#125; &#125; private void setContact(Intent data) &#123;   String contact = readContactFormResult(data);   webView.loadUrl(\"javascript:setContact(\\\"\" + contact + \"\\\")\"); &#125;\nActivity WebView restore流程由于onActivityResult执行webView.loadUrl之前WebView并未restore完成，所以js执行不会生效  \n解决办法1、自定义WebView缓存onActivityResult结果2、WebViewClient.onPageFinished时回调WebView，由WebView将缓存的Activity Result回调至Activity中，并清空缓存Result数据3、Activity判断是否需要对WebView操作具体流程如下：   \n源码，请参见webview-restore\n相关导读android数据共享，Application\\Singleton存储数据出错的问题WebView兼容问题之can not support WebGL\n","categories":["Android"],"tags":["RestoreInstance","WebView","Activity","onActivityForResult","onPageFinished"]},{"title":"Seek-Wealth-Not-Money-or-Status（去寻找财富，而非金钱和地位）","url":"/2025/06/26/Seek-Wealth-Not-Money-or-Status/","content":"Seek Wealth, Not Money or Status去寻找财富，而非金钱和地位Wealth is assets that earn while you sleep财富是资产，资产在你你睡觉时也能一直为你赚钱\nNaval is a prolific tech investor and founder of AngelList财富是资产，资产在你你睡觉时也能一直为你赚钱\nNivi: You probably know Naval from his Twitter account.Nivi: 你可能通过Naval的Twitter账号认识他。  \nWe’re going to talk about his tweetstorm, “How To Get Rich (without getting lucky).” We’ll go through most of the tweets in detail, give Naval a chance to expand on them and generally riff on the topic. He’ll probably throw in ideas he hasn’t published before.我们将会讨论他的推文“How To Get Rich (without getting lucky)”如何致富（不靠运气）。我们将通过详细讨论大部分推文，让Naval有机会进一步阐述概括这个主题。他也有可能抛出新的想法。\nNaval’s the co-founder of AngelList and Epinions. He’s also a prolific tech investor in companies like Twitter, Uber and many more.Naval是AngelList和Epinions的联合创始人。他是一名丰富的科技投资人，投资过Twitter、Uber等公司。\nI’m the co-founder of AngelList with Naval. And I co-authored the Venture Hacks blog with him back in the day.我和Naval共同创立了AngelList。也曾经一起撰写过Venture Hacks博客。\nNaval: The “How to Get Rich” tweetstorm definitely hit a nerve and went viral. A lot of people say it was helpful and reached across aisles.Naval:“How to Get Rich”（如何致富）这篇推文显然戳中了很多人的痛点，并迅速走红。很多人说它非常有帮助，而且打破了圈层，引发了不同群体的共鸣。\nPeople outside of the tech industry—people in all walks of life—want to know how to solve their money problems. Everyone vaguely knows they want to be wealthy, but they don’t have a good set of principles to do it by.不只是科技圈的人，几乎各行各业的人都想知道怎么解决财务上的困扰。大家都知道自己想变有钱，但很多人其实并没有一套靠谱的方法或原则去实现它。\nWealth is assets that earn while you sleep财富是资产，资产在你睡觉时也能一直为你赚钱\nNivi: What’s the difference between wealth, money and status?Nivi: 财富、金钱、地位有什么不同？\nNaval: Wealth is the thing you want. Wealth is assets that earn while you sleep; it’s the factory of robots cranking out things. Wealth is the computer program running at night that’s serving other customers. Wealth is money in the bank that is reinvested into other assets and businesses.Naval: 财富是你想要的。财富是资产，资产在你睡觉时也能一直为你赚钱；它可以是工厂里的机器人为你生产东西。也可以是晚上也能一直服务客户的电脑程序。财富是银行里的钱，可以再投资到其他资产或生意当中。\nA house can be a form of wealth, because you can rent it out; although that’s a less productive use of land than running a commercial enterprise.房子也可以是一种财富，因为你可以将它出租出去。尽管这与经营企业比，是一种生产力较低的一种利用土地的方式。\nMy definition of wealth is oriented toward businesses and assets that can earn while you sleep.我对财富的定义是在你睡觉时能为你赚钱的企业和资产。\nWealth buys your freedom财富买来的是自由\nYou want wealth because it buys you freedom—so you don’t have to wear a tie like a collar around your neck; so you don’t have to wake up at 7:00 a.m. to rush to work and sit in commute traffic; so you don’t have to waste your life grinding productive hours away into a soulless job that doesn’t fulfill you.你想要财富，是因为财富能为你买来自由——让你不必每天戴着像狗链一样的领带，不必早上七点起床赶去上班、堵在通勤的车流中，不必把自己最有生产力的人生时光，浪费在一份毫无灵魂、不带来任何满足感的工作上。\nThe purpose of wealth is freedom; it’s nothing more than that. It’s not to buy fur coats, or to drive Ferraris, or to sail yachts, or to jet around the world in a Gulf Stream. That stuff gets really boring and stupid, really fast. It’s about being your own sovereign individual.财富的真正目的就是自由，仅此而已。它不是为了买貂皮大衣、法拉利、游艇，也不是为了坐湾流私人飞机环球旅行。那些东西很快就会变得无聊甚至愚蠢。真正重要的是：成为一个完全自主、独立的人。\nYou’re not going to get that unless you really want it. The entire world wants it, and the entire world is working hard at it.但你必须真正渴望这种自由，你才可能得到它。全世界的人都想要这种自由，也都在努力争取。\nIt is competitive to some extent. It’s a positive sum game—but there are competitive elements to it, because there’s a finite amount of resources right now in society. To get the resources to do what you want, you have to stand out.在某种程度上，这是一场竞争。虽然它是一个正和游戏，但仍然有竞争的部分，因为当前社会的资源是有限的。如果你想获得资源、去实现你想做的事，你就必须脱颖而出。\nMoney is how we transfer wealth金钱是如何交换财富的具现\nMoney is how we transfer wealth. Money is social credits; it’s the ability to have credits and debits of other people’s time.金钱是社会信用。它代表你拥有他人时间借贷的能力。\nIf I do my job right and create value for society, society says, “Oh, thank you. We owe you something in the future for the work that you did. Here’s a little IOU. Let’s call that money.”如果我做好了我的工作并对社会产生了价值，社会会说，“谢谢你！我们欠你一点什么，以后会补偿你过去做的这些事。给你一张欠条，我们把它叫做‘钱’。”\nThat money gets debased because people steal the IOUs; the government prints extra IOUs; and people renege on their IOUs. But money tries to be a reliable IOU from society that you are owed something for something you did in the past.这种钱会被稀释，因为有人偷走了这些欠条；政府印了更多的欠条；也有人赖账不还。但钱本质上是在努力成为一个可靠的社会欠条，是社会对你过去行为的回报。\nWe transfer these IOUs around; money is how we transfer wealth.我们在人与人之间交换这些欠条；金钱就是我们如何交换财富的具现。\nStatus is your rank in the social hierarchy地位是你在社会体系中的排名\nThere are fundamentally two huge games in life that people play. One is the money game. Money is not going to solve all of your problems; but it’s going to solve all of your money problems. I think people know that. They realize that, so they want to make money.从根本上说，人们在生活中玩着两种巨大的游戏。一个是金钱游戏。金钱并不能解决你所有的问题；但它却能解决你所有需要钱的问题。我认为人们知道这一点。他们意识到了这一点，所以他们想赚钱。\nAt the same time, deep down many people believe they can’t make it; so they don’t want any wealth creation to happen. They virtue signal by attacking the whole enterprise, saying, “Well, making money is evil. You shouldn’t do it.”与此同时，许多人内心深处认为自己赚不到钱，所以他们不希望财富创造发生。他们通过攻击整个行业来发出道德信号，说：”赚钱是邪恶的。你不应该这么做”。\nBut they’re actually playing the other game, which is the status game. They’re trying to be high status in the eyes of others by saying, “Well, I don’t need money. We don’t want money.”但实际上，他们在玩另一种游戏，即地位游戏。他们试图通过说 “我不需要钱” ，“我也不想要赚钱 ”来提高自己在别人心目中的地位。\nStatus is your ranking in the social hierarchy.地位是你在社会体系中的排名。\nWealth is not a zero-sum game. Everybody in the world can have a house. Because you have a house doesn’t take away from my ability to have a house. If anything, the more houses that are built, the easier it becomes to build houses, the more we know about building houses, and the more people can have houses.财富不是零和游戏。世界上每个人都可以有房子。你有房子并不会剥夺我有房子的能力。相反，房子建得越多，建房就越容易，我们对建房的了解就越多，就有越多的人可以拥有房子。\nWealth is a very positive-sum game. We create things together. We’re starting this endeavor to create a piece of art that explains what we’re doing. At the end of it, something brand new will be created. It’s a positive-sum game.财富是一个正和的游戏。我们共同创造财富。我们正在努力创造一件艺术品，来解释我们正在做的事情。最后，我们会创造出全新的东西。这是一个正和游戏。\nStatus is a very old game地位是一个非常古老的游戏\nStatus, on the other hand, is a zero-sum game. It’s a very old game. We’ve been playing it since monkey tribes. It’s hierarchical. Who’s number one? Who’s number two? Who’s number three? And for number three to move to number two, number two has to move out of that slot. So, status is a zero-sum game.另一方面，地位是一种零和游戏。这是一种非常古老的游戏。从猴群时代开始，我们就一直在玩。它是等级制的：谁是第一？谁是第二？谁是第三？而要从第三升到第二，第二就必须让出那个位置。所以，地位是一种零和游戏。\nPolitics is an example of a status game. Even sports is an example of a status game. To be the winner, there must be a loser. Fundamentally, I don’t like status games. They play an important role in our society, so we can figure out who’s in charge. But you play them because they’re a necessary evil.政治就是一种地位游戏的例子。甚至体育比赛也是一种地位游戏。要有赢家，就必须有输家。我本质上不喜欢这种地位游戏。它们在社会中确实扮演着重要角色——帮助我们弄清谁是领导者。但你之所以参与，是因为它们是一种“必要的恶”。\nOn an evolutionary basis—if you go back thousands of years—status is a much better predictor of survival than wealth. You couldn’t have wealth before the farming age because you couldn’t store things. Hunter-gatherers carried everything on their backs.从进化的角度来看——如果你回顾几千年前——地位比财富更能预测一个人的生存能力。在农业出现之前，人们是无法拥有财富的，因为他们无法储存东西。狩猎采集者把一切都背在身上生活。\nHunter-gatherers lived in entirely status-based societies. Farmers started going to wealth-based societies. The modern industrial economies are much more heavily wealth-based societies.狩猎采集者生活在完全基于地位的社会中。而农耕者开始向基于财富的社会转变。现代工业经济体则更多是基于财富的社会。\nPeople creating wealth will always be attacked by people playing status games创造财富的人，总会受到玩地位游戏的人的攻击\nThere’s always a subtle competition going on between status and wealth. For example, when journalists attack rich people or the tech industry, they’re really bidding for status. They’re saying, “No, the people are more important. And I, the journalist, represent the people, and therefore I am more important.”地位和财富之间，总存在着一种微妙的竞争。比如，当记者抨击富人或科技行业时，其实是在争夺地位。他们是在表达：“人民才是最重要的，而我，作为记者，是人民的代表，所以我更重要。”\nThe problem is, to win at a status game you have to put somebody else down. That’s why you should avoid status games in your life—because they make you into an angry combative person. You’re always fighting to put other people down and elevate yourself and the people you like.问题在于：想要在地位游戏中获胜，就必须贬低别人。这也是为什么你应该避免参与地位游戏——因为它会让你变得愤怒、好斗。你会不停地打压他人、抬高自己或你所支持的人。\nStatus games are always going to exist; there’s no way around it. Realize that most of the time when you’re trying to create wealth, you’re getting attacked by someone else and they’re trying to look like a goody-two shoes. They’re trying to up their own status at your expense.地位游戏永远都会存在，这是无法避免的。你需要明白，大多数时候，当你试图创造财富时，攻击你的人，其实是在假装正义。他们想让自己看起来像是“正人君子”，但本质上是在踩着你来提高自己的地位。\nThey’re playing a different game. And it’s a worse game. It’s a zero-sum game, instead of a positive-sum game.他们玩的是另一种游戏——一种更糟糕的游戏。地位游戏是零和游戏，而财富游戏则是正和游戏。\n","categories":["Rich"],"tags":["How to Get Rich","Naval"]},{"title":"WebView兼容问题之can not support WebGL","url":"/2017/12/18/WebView-can-not-support-WebGL/","content":"合作方页面能在浏览器中打开，不能在我们的WebView中打开，运营打上门来。作为一个有态度的码农当然是要怒回去的。于是调试看了对方h5报错如下：\nVM122:158 NativeBridge Ready  app.e35363b….js:1 Uncaught TypeError: Cannot read property 'getExtension' of null    at g (app.e35363b….js:1)    at Object.&lt;anonymous&gt; (app.e35363b….js:1)    at Object.&lt;anonymous&gt; (app.e35363b….js:1)    at r (manifest.d23aea9….js:1)    at Object.&lt;anonymous&gt; (app.e35363b….js:1)    at Object.&lt;anonymous&gt; (app.e35363b….js:1)    at r (manifest.d23aea9….js:1)    at Object.&lt;anonymous&gt; (app.e35363b….js:1)    at r (manifest.d23aea9….js:1)    at Object.&lt;anonymous&gt; (app.e35363b….js:1)g @ app.e35363b….js:1(anonymous) @ app.e35363b….js:1(anonymous) @ app.e35363b….js:1r @ manifest.d23aea9….js:1(anonymous) @ app.e35363b….js:1(anonymous) @ app.e35363b….js:1r @ manifest.d23aea9….js:1(anonymous) @ app.e35363b….js:1r @ manifest.d23aea9….js:1(anonymous) @ app.e35363b….js:1(anonymous) @ app.e35363b….js:1r @ manifest.d23aea9….js:1(anonymous) @ app.e35363b….js:1r @ manifest.d23aea9….js:1(anonymous) @ app.e35363b….js:1r @ manifest.d23aea9….js:1(anonymous) @ app.e35363b….js:1r @ manifest.d23aea9….js:1window.webpackJsonp @ manifest.d23aea9….js:1(anonymous) @ app.e35363b….js:1\n我们观摩对方代码\ne=t.getContext(&quot;experimental-webgl&quot;),\nn=e.getExtension(&quot;WEBGL_debug_renderer_info&quot;);\nreturn n?e.getParameter(n.UNMASKED_RENDERER_WEBGL):\n&quot;Apple unknown GPU&quot;\nH5中采用了WebGL，android WebView v36才开始支持WebGL，所以出现了这样的兼容性问题。运营再怒，在你们的App中出现这个问题，但是就在该手机的浏览器、微信中都是可以打开的。有态度的码农知道这次有口莫辩了。如果对方用的Chrome，那问题一定是同步的，但是其它浏览器自研内核，有的是支持的。于是这时候我们应该怎样微笑着玩下去，代码截图，解决方案截图与合作方的工程师相爱相杀去了。  \n相关导读Activity调用外部为WebView设值不成功问题解决301 造成WebView 不能正常访问WebView restore\n参考WebView for Androidenabling-webgl-support-for-android-webview\n","categories":["Android"],"tags":["WebView","WebGL","兼容问题","experimental-webgl","WEBGL_debug_renderer_info","v36","chrome"]},{"title":"XML元素名称规范","url":"/2023/05/11/What-is-XML-Naming-Rules/","content":"背景使用dom4j生成XML，期望结果生成XML数据&lt;gNB间NG切换成功率(%)&gt;100&lt;/gNB间NG切换成功率(%)&gt;但是抛错java.lang.IllegalArgumentException: Illegal character in name: 'gNB间NG切换成功率(%)'.\tat org.dom4j.QName.validateName(QName.java:340)\tat org.dom4j.QName.&lt;init&gt;(QName.java:151)\tat org.dom4j.tree.QNameCache.createQName(QNameCache.java:245)\tat org.dom4j.tree.QNameCache.get(QNameCache.java:115)\tat org.dom4j.DocumentFactory.createQName(DocumentFactory.java:191)\tat org.dom4j.tree.AbstractElement.addElement(AbstractElement.java:760)\tat Dom4jTest.test_AddTagBySpecial(Dom4jTest.java:25)\n\n抛错的源码查看方法at org.dom4j.QName.validateName(QName.java:340)private static final Pattern RE_NAME = Pattern.compile(\"[:_A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-\\u1fff\\u200c-\\u200d⁰-\\u218fⰀ-\\u2fef、-\\ud7ff豈-\\ufdcfﷰ-�][:_A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-\\u1fff\\u200c-\\u200d⁰-\\u218fⰀ-\\u2fef、-\\ud7ff豈-\\ufdcfﷰ-�-.0-9·̀-ͯ‿-⁀]*\");private static void validateName(String name) &#123;    if (!RE_NAME.matcher(name).matches()) &#123;        throw new IllegalArgumentException(String.format(\"Illegal character in name: '%s'.\", name));    &#125;&#125;dom4j为什么抛出这个错，是XML的规则就是这样还是dom4j版本不正确还是什么原因？\nXML Naming Rules参见XML Elements\n","categories":["Java"],"tags":["dom4j","XML"]},{"title":"Makefile如何使用","url":"/2024/02/06/What-is-Makefile/","content":"工程化编译项目时，Java用Maven\\Gradle，前端用npm，C/C++用Make使用Make命令编译C/C++时，是通过Make工具实现。推荐使用w64devkitw64devkit支持Linux命令\n\n根据更改的源文件，自动确定需要更新哪些文件。它还自动确定更新文件的正确顺序，以防一个非源文件依赖于另一个非来源文件。因此，如果您更改一些源文件，然后运行Make，则不需要重新编译所有程序。它只更新那些直接或间接依赖于您更改的源文件的非源文件。如何确定依赖的呢，来源与我们在Makefile中指定的dependencies\nMake不限于任何特定的语言。所有能在命令行运行的编程语言都能处理（Java\\Golang\\Python…）。另外基于文件的改变然后更新另外的文件也可以。\n\nMakefile中的一条规则告诉Make如何执行一系列命令，以便从源文件构建目标文件。它还指定了目标文件的依赖项列表。此列表应包括用作规则中命令输入的所有文件（无论是源文件还是其他目标文件）。\ntarget:   dependencies ...          commands          ...\nhello: hello.o\tg++ -o hello hello.ohello.o: hello.cpp\tg++ -c hello.cpp\n更新机制运行Make时，可以指定要更新的特定目标；否则，Make会更新makefile中列出的第一个目标。当然，必须首先更新生成这些目标所需的任何其他目标文件作为输入。Make使用makefile来确定哪些目标文件应该更新，然后确定哪些文件实际上需要更新。如果目标文件比其所有依赖项都新，那么它已经是最新的，不需要重新生成。其他目标文件确实需要更新，但顺序正确：每个目标文件都必须重新生成，然后才能用于重新生成其他目标。\nMakefile文件命名Make自动查找makefile文件，顺序为GNUmakefile&gt;makefile&gt;MakefileGUNmakefile:不建议使用，只能支持GUN makemakefile:所有版本都能识别Makefile:推荐，最常用\n运行make时没有找到上述文件会报错，但可以手动指定文件名make -f &lt;filename&gt;make --file=&lt;filename&gt;\n","categories":["C/C++"],"tags":["Makefile"]},{"title":"牛仔裤中的牛仔是什么","url":"/2023/05/12/What-is-jeans/","content":"Q牛仔裤中的牛仔是什么\nA“牛仔裤”一词源自英文单词“jeans”，最早可以追溯到1567年意大利热那亚港水手穿的一种粗帆布制作的裤子，当时水手们喜欢穿着这种粗糙而结实的布料做成的工作裤子，称之为Genoese, Genes，与Jeans有着相似的发音。1850年淘金热的浪潮下，移民到美国的巴伐利亚人李维·斯特劳斯创立了李维斯公司，该公司生产的帆布工装裤就是世人所知的牛仔裤的鼻祖。这种布料结实耐磨，十分适合应付繁重的日常劳作，受到当时矿工们的喜欢。因此，牛仔裤中的“牛仔”并不是指牛，而是指穿着这种裤子的工人和冒险家。\n","categories":["Other"],"tags":["Kids"]},{"title":"android数据共享，Application\\Singleton存储数据出错的问题","url":"/2016/05/14/android-data-store/","content":"两天终于完成了某模块的数据共享问题的改造。此次问题就是传说中万恶的Application及Sigleton存数据的问题。曾经有大拿老张疑惑说Android怎么可能没有一个安全的临时存储数据的地方。接下来我们看一下在本次应用中实际发生的问题。并查看解决知名app掘金v3.1.1出现的这个问题采用官方提供api机制来解决问题。\n一、问题应用切换到后台返回程序Crash或数据丢失。甚至在小内存手机中调用系统相机再回来应用就已经重启了\n二、解决办法采用Intent及setArgments的方式来传值，采用onSaveInstanceState保存数据以供恢复。\nActivity中Fragment恢复\n除了界面中传值及数据恢复外还涉及到界面的恢复。各View都由系统保存并恢复，但是在涉及到Fragment时，不会为我们直接将Fragment恢复到我们的Activity中，需要我们使用getFragmentManager().findFragmentByxxx获取后再add或replace上去。  \n采用以上的方法基本可以解决问题，能使用户走正常流程。但是会发现数据有些卡顿，甚至会偶现不能正常恢复的情况。追求极致的程序猿又要开始折腾了。\n三、优化1、减小数据保持数据短小轻快，这样可以更快启动下一界面及恢复\n2、本地缓存如果数据量确实大不能保持精练，则采用Singleton加本地缓存（若对象不存在则从本地读取）。这样可以保证快速启动界面，然后再加载数据。本地缓存视数据大小及结构选择存储方式。可以简单粗暴的采用Preference、ObjectFile，或者数据库、LruCache等.\n四、诱因及说明【没有耐心直接略过，真心废话】Home回到桌面或者调用其它应用，我们的应用转入后台后降低优先级被回收（整个Application会被会关掉，所有变量数据都会被清空）。但是，切回应用Android的恢复机制却是重新启动Application，不进入LaunchActivity，而是直接恢复到最近的界面。这个时候问题来了，若正常重新启动应用程序，走正常流程，数据重新生成没有问题。但是直接进入最近界面之前生成的数据已经丢失了，此时直接引用数据将会引起Crash。这时看官们就说了，直接加个判断是否为Null不就可以了。但数据为Null，用户不能走正常流程，这一定不是我们想要的。那么有没有一种机制解决这个问题呢，答应是有的。Android提供了onSaveInstanceState来保存数据，恢复时可以从savedInstanceState中获取数据。 OK，讲到这里方案已经呼之欲出了，答案是请看本文前面的内容。   \n五、实战分析——掘金v3.1.1进入掘金文章详情页切换到后台再恢复时会出现“文章加载失败”的提示也是这个问题导致。WebViewEntryActivity(文章详情)我们分析一下代码，文章详情中的url由Entry对象v中从获取（LeanCloud）  \n首先来看加载失败的代码\nprivate void q() &#123;  if (v == null) aj.a(this, \"文章信息加载失败\");  this.editorName.setText(getIntent().getStringExtra(\"name\"));  g.a(this).a(getIntent().getStringExtra(\"avatar\")).a(this.avatar);  return;  this.commentCount.setText(Entry.getString(v.getCommentCount()));  b.a(v, new ff(this));  if ((!(k.b(v.getUrl()))) || (v.getTags() == null) || (v.getTags().size() &lt;= 0)) break;  com.daimajia.gold.c.z.a(v.getTags(), new fg(this));  u();&#125;\nv的获取方式有两个地方，一个是在方法a中传入，另外一个为EventBus调用onEventMainThread时传入。我们切回掘金文章详情页时，WebViewEntryActivity生命周期会重新执行一次，经过查找引用的地方，我们确定方法a不会被执行。EventBus处为ShareEntryActivity调用，显然这个方法也没法执行。v就未能被初始化，为null，就必然提示“文章信息加载失败”\npublic static void a(Entry paramEntry)&#123;  v = paramEntry;&#125;\npublic void onEventMainThread(f paramf)&#123;  if ((v != null) &amp;&amp; (v.getUrl().equals(paramf.a.getUrl())))    v = paramf.a;&#125;\n具体解决办法见上文。但是对于View的状态其实Android自动作了处理，这里因为是Webview才出现这个问题，那要么解决呢？\n@Override protected void onSaveInstanceState(Bundle paramBundle) &#123;  super.onSaveInstanceState(paramBundle);  mWebView.saveState(paramBundle);&#125;\npublic void onCreate(Bundle savedInstanceState) &#123;  super.onCreate(savedInstanceState);  if (savedInstanceState != null) &#123;    mWebView.restoreState(savedInstanceState);  &#125; else &#123;    mWebView.loadUrl(\"http://2tu.github.io/2016/05/14/android-data-store/\");  &#125;&#125;\n五、PS通过 开发者选项-&gt;不保留活动 制造该现象采用官方推荐方式开发相关导读Activity调用外部为WebView设值不成功问题解决\n","categories":["Android"],"tags":["Singleton"]},{"title":"annotationProcessor 引用后编译时不生效问题","url":"/2020/04/04/annotation-proccor-by-gradle4-7/","content":"Gradle升级后Processor无法在编译时生效升级fit后忽然发现在annotaionProcessor后编译并没有生成。原因在哪里呢？将fit库的gradle版本从4.6升级到了5.6.4，原来从gradle4.7开始不再帮助生成，需要我们自己在库中解决。    \n两种方案\n1、processor中添加anntationProcessor在comiple库的build.gradle中加入后，其它不需要动即可（我的库使用的AutoServerice）\nannotationProcessor deps.autoservice\n2、自己写一个gradle build plugin需要用户使用时引入gradle plugin方能生效  \napply plugin: 'custom.plugin'\n参考 Incremental annotation processing annotation processor 为啥没有被调用? Annotation processor @autoserviceButter Knife\n","categories":["Android"],"tags":["Gradle"]},{"title":"使用antd-init创建第一个可以运行的ant design","url":"/2019/09/12/antd-init/","content":"1、安装npm  \n2、安装antdnpm install antd-init -g\n3、创建ant-demomkdir antd-demo\n4、进入antd-demo目录cd antd-demo\n\n5、安装npm依赖antd-init --type plain-react产生以下文件    node_modules    index.css    index.js    package.json    webpack.config.js\n6、运行 (npm run build构建部署)npm start\n7、根据listen端口进行访问           dora: listened on 8000webpack: bundle build is now finished.\n\n8、最后  antd-init@2 仅适用于学习和体验 antd，如果你要开发项目，推荐使用 create-umi 进行项目初始化。umi 是一个可插拔的企业级 React 前端应用框架，已在生产环境广泛应用。antd-init@2 is only for experience antd. If you want to create projects, it’s better to init with create-umi. umi is a pluggable enterprise-level react application framework.\nUsage:\nmkdir myapp &amp;&amp; cd myappyarn create umi\nVisit https://github.com/umijs/create-umi/ to learn more.\n—  END  —分享程序员所看、所想、所悟、所望\n","categories":["Web"],"tags":["antd"]},{"title":"人脸支付怎么敢采用后4位手机号","url":"/2019/04/23/assert-facepay-dragonfly-by-4/","content":"我们的人脸支付产品只需要后4位手机号（用户号码）即可辨识用户，这是比支付宝、微信自助机，蜻蜓优秀的地方（需要11位手机号）。但是今天猛然发现唯一的优势不再。\n优势是一种市场说法，对于技术人来讲，原理是少量用户比对。因为注册用户少，用户号码能做到1:1，个别需要1:N(N&lt;=4)。所以目前用户体量下无需担心影响用户体验。而支付宝、微信用户体量那么大，采用11位手机号才能1:1。\n支付宝、微信到底如何做到只需后4位用户号码，甚至不需要输入手机号的呢？\n支付宝用户超10亿   \n去除海外用户  \n去除尚未开通刷脸支付用户[后期越来越多]    \n剩下的数据依然庞大，还能怎么办呢？\n\n从人脸对比原理上提高几毫秒在这样的用户体量下九牛一毛都不算。所以是否应该从业务场景下寻找解决方案。\n以下观点属于猜想\n人脸都是跟着人走的，人的使用习惯，活动轨迹都是有规律的。\n我们是否还可以从用户使用城市、地区、甚至是否常在哪个店消费来建立优先比对，或者本地比对等。或许还可以根据性别等先过滤一批。\n总之从技术上来讲1:N很可怕，但是从业务上拆分后数据量也没有想象中难以承受。\n附录符合猜想的蜻蜓支付视频\n异地第一次在某店消费\n\n\n\n本地第三次某店蜻蜓支付\n\n\n\n旧文刷脸支付-人脸比对效率\n—  END  —分享程序员所看、所想、所悟、所望\n","categories":["Other"],"tags":["人脸支付"]},{"title":"brew install mac安装失败的问题","url":"/2015/10/16/brewInstall/","content":"\n问题：brew 安装失败\n思路：将github仓库放到本地，不用ruby下载\n解决办法：\n\n1、下载https://raw.githubusercontent.com/Homebrew/install/master/install文件(使用浏览器打开，另存为也可以)，命名为install  \n2、在github上把Homebrew(https://github.com/Homebrew/homebrew)的库下载下来(下载zip包即可)把下载的zip包放在文件夹”brew”(自己建立)内，同时在 “brew” 文件夹内新建文件夹”brewRemote.git”把步骤1下载下来的install文件也放进”brew”文件夹中3.下面开始使用 shell，前提，shell先进入到”brew”文件夹内\ncd brewRemote.git\ngit init --bare  \ncd ../homebrew-master\ngit init\ngit add .\ngit commit -m &quot;create project&quot;\ngit remote add origin  brewRemote.git(的绝对路径)\ngit push -u origin master\n现在，我们本地就有了Homebrew的git库:brewRomote.git接下来，修改install文件：应该在第7行左右，把\nHOMEBREW_REPO = &apos;https://github.com/Homebrew/homebrew&apos;\n改为：    HOMEBREW_REPO = &#39;/Users/tu/Documents/brew/brewRomote.git&#39;  \n这里就是把Homebrew的github库，替换为本地库。注意：上面的brewRomote.git(/Users/tu/Documents/brew/brewRomote.git)的绝对路径为我的，你要替换为你自己本地的绝对路径，最后继续执行ruby命令(注意：shell当前路径依然为brew)\nrm -rf /usr/local/Cellar /usr/local/.git &amp;&amp; brew   \ncleanup\nruby install  \n第一行的rm命令，是为了防止之前你安装Homebrew失败而残留的文件，导致这次安装失败ruby install执行之后，安装命令行提示安装，应该会安装成功。安装成功后，执行以下命令：  \n`brew doctor`    \n这个命令是Homebrew的自我检测命令，看看有没有配置不对的地方。但是我们使用的本地的git库brewRomote.git,所以会检测出这个有问题，我们接下来修改这个问题。找到这个文件 /usr/local/.git/config,由于.git文件是隐藏文件夹，你可以使用命令行来查找  \nopen /usr/local/.git   \n这样你就能找到config文件了使用编辑器来修改config文件  \nurl = /Users/baidu/TestTmp/yanshi/brewRomote.git改为       \nurl = https://github.com/Homebrew/homebrew\n保存config文件，大功告成！，再使用brew doctor检查一下，应该就没问题了。\n原文：http://doc.okbase.net/shede333/archive/122619.html\n","categories":["Other"],"tags":["brew"]},{"title":"香港卡全攻略","url":"/2023/11/19/bankcard-hongkong/","content":"为什么要办香港卡？保险？参与港美股？参与加密货币？OpenAI付费？公司股票不转回？对于我来说，听着牛逼想要但又不是必须的理由。最后决定办理是因为觉得港股券商入金有奖励，家人可以顺便去玩一圈。\n选择哪个银行？有那么多银行，我们可以办哪些，哪些又比较好呢？从发币行角度考虑\n\n香港上海汇丰银行\n渣打银行（香港）\n中国银行（香港）三家银行都是在全球开展业务。从网上的信息来看汇丰和中国银行很好办，渣打不太好办。另外虚拟银行众安银行、天星银行、蚂蚁银行等，没有考虑和办理就不列了。\n\n\n\n\n\n香港上海汇丰银行\n中国银行\n\n\n\n\n总部\n伦敦\n中国\n\n\n办理难度\n容易\n容易\n\n\n转汇费用\n据说同名内地香港互转不要手续费\n同名内地香港互转不要手续费\n\n\n\n听说汇丰和中国银行从内地卡转入香港卡不要手续费。我办了汇丰之后就飘了不想再办就出去玩了。回来内地后去汇丰银行办理内地卡，没想到她直接告诉我只接待Premier客户，有存款要求不然有管理费。\n怎么办理？两种方式\n\n直接到营业网点线下排队办理\n  如果人多去晚了可能无法办理，或者预约的人数多也可能被拒绝\n\n网上预约，再到网点办理\n  网上预约后无需再早去现场排队拿号，直接告诉接待人员，然后就给你安排了\n\n\n\n怎么预约汇丰银行多久开始提前预约？公众号上写提前2个工作日，预约后，会有香港电话打过来问你是哪天要去，去哪个分行，她登记后会将信息转至分行分行的人会再次打电话给你，确认上门时间\n\n关注微信公众号汇丰香港，微信号：hsbc-hongkong\n预约开户点击“预约开户”按钮进入页面后，填写相关信息联络电话，填写你内地的，要改成+86产品及服务，选择汇丰ONE选择会面日期，香港银行周一到周五营业时间为上午9点到下午4点，周六营业时间为上午9点到下午1点，我是周六去的选择会面地区，我选择的网红网点葵芳分行，新界-》葵涌及荃湾\n\n银行登记提交完后，第二天晚上17:59银行电话我询问我具体办理日期和时间确认我们选择的区域的分行，或者你也可以讲自己想要的分行告知开户时需要提供的资料分行同事会再电话告知需要提供的资料\n\n分行电话隔天18：:01分行电话，告知几点带上身份证、港澳通行证、过关小票\n\n\n中国银行可以提前7个工作日预约，不能约当天，工作日包含周六中国银行预约时，公众号里面只能选择还能预约的分行，不会打电话给你确认，所以公众号预约成什么地方就是什么地方\n\n关注微信公众号中银香港微服务，微信号：BOCHK_Banking\n预约开户点击”银行服务”-》“我要预约”按钮进入页面后，点击“预约开户”\n\n资料总结一下要带哪些资料\n\n身份证\n港澳通行证（有效期不低于3个月）\n过关小票\n地址证明（不一定需要，看客户经理）\n收入来源（不一定需要，看客户经理）\n存款（不一定需要，看客户经理）我在葵芳分行只要了身份证、港澳通行证、过关小票\n\n","categories":["Other"],"tags":["香港卡"]},{"title":"浏览器打开图片链接时直接显示或下载到底怎么回事","url":"/2020/07/17/browser-view-or-download-image-by-header/","content":"最近瞎JB搞了一通，各个项目都是喊组装上就交付，难以有时间学习总结，简直违反程序员的基本原则。很多时候已经忘记踩了哪些坑，如何解决的了。 \n问题图片上传至阿里云OSS生成链接在浏览器中打开是直接下载文件，而需求需要打开图片而非下载。\n常用方式浏览器中的图片，通常印象中，前端上传文件获取url，终端当然是下载再展示。浏览器端都是img标签展示\n&lt;img src=\"/css/images/favicon.png\"/&gt;\n下载图片及附件时都是右键保存或者点击按钮下载写入文件流中。最近的需求中提到上传的图片生成的url，在浏览器中是打开而非下载文件 。我们正常上传到我们服务器上的是没问题的。这个问题出在阿里云OSS上？到底要怎么玩？\nHEADER就经验来讲肯定是响应头header的问题。Android有类似的机制，view-type啥的，你是直接在别的应用中打开，还是怎么操作。对比下载和打开图片两种不同链接  \n\n打开图片链接：http://blog.520wa.com/css/images/watermark_bg.jpegResponse Headers\nHTTP/1.1 200 OKServer: nginx/1.10.2Date: Fri, 17 Jul 2020 15:43:50 GMTLast-Modified: Sun, 19 Apr 2020 08:52:37 GMTContent-Type: image/jpegContent-Length: 101372ETag: \"5e9c1155-18bfc\"Accept-Ranges: bytes\n下载图片链接（网上找的，失效了就自己找一个）：http://pic.96weixin.com/ueditor/20200511/1589185236200665.jpg?x-oss-process=image/resize,m_lfit,w_120  \nResponse Headers\nHTTP/1.1 200 OKServer: TencentCOSDate: Fri, 17 Jul 2020 15:42:07 GMTLast-Modified: Mon, 11 May 2020 16:20:36 GMTContent-Type: image/jpegContent-Length: 33302Content-Disposition: attachment; filename*=\"UTF-8''1589185236200665.jpg\"\n这个响应头太多，我只截取关键部份。  \n对比不同关键点在于下载图片多了\nContent-Disposition: attachment; filename*=\"UTF-8''1589185236200665.jpg\"\n而1589185236200665.jpg就是我们下载图片保存到本地的文件名。\n结论在常规的HTTP应答中，Content-Disposition 响应头指示回复的内容该以何种形式展示，是以内联的形式（即网页或者页面的一部分），还是以附件的形式下载并保存到本地。看了这么多，就是因为Content-Disposition指定了下载，所以就下载了，没有Content-Disposition响应头就是显示。\n阿里云OSS上传图片直接显示解决方案那么在阿里OSS上传又是怎么解决了，毕竟我们只上传了图片，也没有指定响应头。详细OSS的机制我已不想追究，没有意义，搞懂原理，只想睡个好觉，加班太JB累。网友给出的解决办法  \nObjectMetadata metadata = new ObjectMetadata();// 指定Content-Typemetadata.setContentType(getContentType(path.substring(path.lastIndexOf(\".\"))));put.setMetadata(metadata);\npublic static String getContentType(String FilenameExtension) &#123;    if (FilenameExtension.equalsIgnoreCase(\".bmp\")) &#123;        return \"image/bmp\";    &#125;    if (FilenameExtension.equalsIgnoreCase(\".gif\")) &#123;        return \"image/gif\";    &#125;    if (FilenameExtension.equalsIgnoreCase(\".jpeg\") ||        FilenameExtension.equalsIgnoreCase(\".jpg\") ||        FilenameExtension.equalsIgnoreCase(\".png\")) &#123;        return \"image/jpg\";    &#125;    if (FilenameExtension.equalsIgnoreCase(\".txt\")) &#123;        return \"text/plain\";    &#125;    return \"image/jpg\";&#125;\n\n","categories":["Web"],"tags":["OSS"]},{"title":"表达式引擎预研","url":"/2022/09/02/compare-expression-language/","content":"背景最后业务有需求需要动态计算表达式，基于公式对某些值进行再加工计算。所以对表达式引擎进行一个简单的了解。表达式引擎就是为了表达式的动态求值计算。通常对于各个类库对比，我们需要看厂商、License、社区活跃度、优缺点等来判断其符合的使用场景，最终决定应该用哪个。由于时间较紧，只做简单收集，在项目中本已使用AviatorScript的情况下就选择了它。\n特性对比\n\n\n\nAviatorScript\nGroovy\nSpEL\nQLExpress\n\n\n\n\nVersion\n5.3.2\n4.0.4\n5.3.22\n3.3.0\n\n\n厂商\nkillme2008\nApache\nSpring\nalibaba\n\n\nLicense\nGPL V3\nApache 2 License\nApache License 2.0\nApache License 2.0\n\n\nLanguage\n基于Java\n基于Java\nJava\nJava\n\n\n优点\n高性能 轻量级\nFlat learning curvePowerful featuresSmooth Java integrationDomain-Specific LanguagesVibrant and rich ecosystemScripting and testing glue\n\n线程安全高性能弱类型脚本语言安全控制代码精简\n\n\n\n还有OGNL、Drools、EasyRules\n另外MVEL、IKExpression很久未更新，不列\n","categories":["Java"],"tags":["Aviator"]},{"title":"C++构造函数设计原理","url":"/2019/02/14/cpp-constructor-rule/","content":"构造函数，我们通常看到的如下Point(void)&#123;    x = 0.0;    y = 0.0;&#125;Point(double xP, double yP)&#123;    x = xP;    y = yP;&#125;与函数相比没有返回值部份（连void也没有），且与构造函数名与类名称相同。函数名称与类名相同，每个对象都会初始化，可以由用户定义的函数初始化，也可以由系统编译器调用默认构造初始化。这就要求编译器必须总能知道调用哪个函数是构造函数，最简单也最符合逻辑的方式就是指定构造函数的名称与类名相同。没有返回值，如果有返回值，则编译器必须知道如何处理返回值，这样会增加编译器的工作，降低效率。所以在定义构造函数时不能指定返回类型，即使void类型也不行。\n","categories":["C/C++"],"tags":["构造函数"]},{"title":"C++重载默认参数函数问题？","url":"/2019/01/18/cpp-overload-default-param/","content":"函数重载以参数类型和参数个数不同区分。如:int add(int m1, int m2);int add(int m1, int m2, int m3);int add(int m1, int m2, int m3, int m4);int add(char m1, char m2);以上程序大家都没有什么疑惑。那么下面的程序呢？int add(int m1, int m2);int add(int m1, int m2, int m3);int add(int m1, int m2, int m3, int m4 = 0);int add(char m1, char m2);看着也无大问题，但是编译却会报错原因在于C++中有了默认参数后4个int参数的方法相当于int add(int m1, int m2, int m3, int m4 = 0);int add(int m1, int m2, int m3)&#123;    int m4(0);&#125;所以再定义一个int (int m1, int m2, int m3)已经造成了歧义。由此设置默认参数需要注意2点  \n\n只能由后往前  \n不能对少于参数个数的函数进行重载\n\n","categories":["C/C++"],"tags":["Override"]},{"title":"C++编译器有哪些","url":"/2023/10/21/cpp-compiler/","content":"没想到C++环境搭建都这么麻烦，编译器有很多种。\n\nMSVC\nw64devkit\nClang\n\n没有研究是觉得有些复杂。\n在编译时会将我们include，#define等合并成一个文件。那如何看到这个编译的中间文件呢？在Visual Studio中设置\n代码#include &lt;iostream&gt;int main() &#123;\tstd::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\tstd::cin.get();&#125;\nCtrl + F7编译后，可以从Debug目录下看到FileName.i文件中已经包含了include的 iostream代码\n注意：Visual Studio和Visual Studio Code是不同的工具\n下一个看看C++如何建立link，为什么C++中不像java一样需要导入包，就可以link，然后引用呢？如果有两个同名的函数，那link的时候会报错吗？\n","categories":["C/C++"],"tags":["Compiler"]},{"title":"基于数据决策春节怎样回家最不堵车","url":"/2018/01/29/data-decision-go-home-time-in-the-spring-festival/","content":"互联网从业者的优势在于会查看利用网络上公开数据还有14个工作日就过年了，各大公司即将封版，很多已无心工作数着日子等过年（作者除外，还有两个版本需上线）。 数日子过年的时候不得不谋划如何休假使假期时间最长，可惜今年是前4后3，没那么好。今年过年得回我家、老婆家，分别为200公里-3小时、450公里-6小时左右。堵在路上听着儿子撕心裂肺的哭声犹如应用宕掉了一样让人着急心疼。除了每过一个服务区重新导航一次以外还能做些什么避免呢？年底时各大地图、打车软件发布过各互联网公司加班情况，那他们是否也有春节的交通预测呢？答案是有的。\n查看历史数据百度、高德都有相关数据，但是还未有2018年的春节预测。高德，17年1月16发布2017年春节出行预测报告，放假前一周周一，所以今年是否会在2018-02-05发布，值得关注。百度，17年2月发布2017年春运迁徙总结报告，应该是迁徙后得出的数据。也许更为接近事实。既然已有报告，我们进行简单对比，取个大概趋势休假出行即可。高德-春运期间全国高速公路网拥堵趋势百度-春运全国迁徙趋势节前拥堵情况几乎一致，但是打破了我原本认为二十八、二十九、除夕会很堵车的情况，由此取消节前先送老婆孩子回家的决定。节后略有不同，主要分析初六、七、八、九，因为初七、八上班，九放假，不排除很多人七、八休假的可能。初六毋庸置疑最拥堵，余下三天高德认为初七最不堵，百度认为初九的交通情况略好于初七。  \n所以大致决策是除夕回家，初七回市区，留着年假带宝宝出去浪里咯浪~最后实时关注2月5日的高德预测最最后表示一切决定听老婆的","categories":["Data"],"tags":["数据决策","春运交通情况"]},{"title":"使用Java、Excel数据分析如何有效投资房产","url":"/2018/01/27/data-analysis-house-price/","content":"写在前面的话2017年IT业中多起猝死、自杀，创业的九死一生，各大公司清算、裁员等。年底也总是充斥着各种活动刷屏，年终总结、账单等。30岁的程序猿什么的，不幸我们可能也是其中之一。要改变现状，离不开钱与投资，提到投资就不得不提房。过去数十年的房价颠覆了努力工作改变生活的思维。作为程序猿比他人多的优势在于可以利用互联网数据进行数据分析决策，接下来看看基于链家中重庆渝北区人和二手房及国家全国商品房销售面积统计的简单数据分析。\n数据收集链家公共数据链家的url很标准，我们要获取的数据如下【人和二手房_重庆人和二手房出售】(重庆链家网)，2018年1月27日数据为472条，共16页，url格式为https://cq.lianjia.com/ershoufang/renhe/pg1/…https://cq.lianjia.com/ershoufang/renhe/pg16/  \nJava Jsoup爬虫现在全职Java，且为了快速实现采用Jsoup获取Html数据，代码非常简单\nDocument document = Jsoup.connect(domain + uri)   .userAgent(\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\")   .timeout(30000).get();\n保存Html数据至本地文件厚道的链家并未做防爬虫，也有可能是为了对搜索引擎友好，提高曝光率。数据获取后要保存至本地文件就简单了，合并后代码如下\npublic String saveHtml(String domain, String uri) &#123;  FileOutputStream out = null;  File dest = new File(\"src/temp_html/\" + (uri.endsWith(\"/\") ? uri.substring(0, uri.length() - 1) : uri) + \".html\");  try &#123;    Document document = Jsoup.connect(domain + uri)        .userAgent(\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\")        .timeout(30000).get();    if (!dest.getParentFile().exists()) &#123;      dest.getParentFile().mkdirs();    &#125;    if (!dest.exists()) &#123;      dest.createNewFile();    &#125;    out = new FileOutputStream(dest, false);    out.write(document.toString().getBytes(\"UTF-8\"));    out.close();  &#125; catch (IOException e) &#123;    e.printStackTrace();    return null;  &#125; finally &#123;    IOUtils.closeQuietly(out);  &#125;  return dest.getPath();&#125;\n通过Jsoup解析数据至Excel再将html中数据解析使用POI写入Excel就相对简单了，主要在于规则匹配\n解析数据public List&lt;House&gt; parseHtml(String fileName) &#123;    List&lt;House&gt; houses = null;    //读取本地html的路径    File file = new File(fileName);    //写个循环读取这些文件的名字    try &#123;      if (file.isFile()) &#123;        logger.info(\"文件&#123;&#125;开始解析\", fileName);        //下面开始解析本地的html        Document doc = Jsoup.parse(file, \"UTF-8\");        Elements sellListContents = doc.select(\"ul.sellListContent\");        if (!ObjectUtils.isEmpty(sellListContents)) &#123;          Element sellListContent = sellListContents.first();          Elements sellContents = sellListContent.select(\"li.clear\");          if (!ObjectUtils.isEmpty(sellListContents)) &#123;            houses = new ArrayList&lt;&gt;(sellContents.size());            for (int i = 0; i &lt; sellContents.size(); i++) &#123;              Element sellList = sellContents.get(i);              Elements sellElements = sellList.select(\"div.clear\");              if (null != sellElements &amp;&amp; sellElements.size() == 1) &#123;                House house = new House();                Element infoElement = sellElements.first();                Element titleElement = infoElement.select(\"div.title\").first().select(\"a[href]\").first();                house.setTitle(titleElement.text());                house.setUrl(titleElement.attr(\"href\"));                Element houseInfoElement = infoElement.selectFirst(\"div.houseInfo\");                house.setVillage(houseInfoElement.select(\"a\").first().text());                String houseInfo = houseInfoElement.text();                String[] houseInfos = houseInfo.split(\"\\\\|\");                for (int j = 1; j &lt; houseInfos.length; j++                    ) &#123;                  switch (j) &#123;                    case 1:                      house.setStructure(houseInfos[j].trim());                      break;                    case 2:                      house.setAcreage(houseInfos[j].replace(\"平米\", \"\").trim());                      break;                    case 3:                      house.setOrientation(houseInfos[j].trim());                      break;                    case 4:                      house.setDecoration(houseInfos[j].trim());                      break;                    case 5:                      house.setElevator(houseInfos[j].trim());                      break;                  &#125;                &#125;                Element positionInfoElement = infoElement.selectFirst(\"div.positionInfo\");                house.setRegion(positionInfoElement.select(\"a\").first().text());                String position = positionInfoElement.text().split(house.getRegion())[0].trim();                house                    .setPosition(position.lastIndexOf(\"-\") == position.length() - 1 ? position.substring(0, position.length() - 1).trim() : position);                house.setTag(infoElement.selectFirst(\"div.tag\").text());                Element priceInfoElement = infoElement.selectFirst(\"div.priceInfo\");                house.setTotalPrice(priceInfoElement.selectFirst(\"div.totalPrice\").text().replace(\"万\", \"\"));                house.setUnitPrice(priceInfoElement.selectFirst(\"div.unitPrice\").text().replace(\"单价\", \"\").replace(\"元/平米\", \"\").trim());                logger.info(\"解析第&#123;&#125;个元素，结果为：&#123;&#125;\", i, house.toString());                houses.add(house);              &#125;            &#125;          &#125;        &#125;      &#125;    &#125; catch (Exception e) &#123;      logger.error(\"文件&#123;&#125;解析错误\", fileName, e);    &#125;    return houses;  &#125;\n写入Excelpublic String writeExcel(String fileName, List&lt;House&gt; houses) &#123;    logger.info(\"文件&#123;&#125;开始写入\", fileName);    try (POIFSFileSystem fs = new POIFSFileSystem(new FileInputStream(fileName))) &#123;      Workbook workbook = new HSSFWorkbook(fs);      HSSFSheet sheet = (HSSFSheet) workbook.getSheetAt(0);      final int preLastRowNum = sheet.getLastRowNum();      logger.info(\"文件&#123;&#125;,上次行数为&#123;&#125;\", fileName, preLastRowNum);      for (int i = 0; i &lt; houses.size(); i++) &#123;        Row row = sheet.createRow(preLastRowNum + i + 1);        House house = houses.get(i);        row.createCell(0).setCellValue(preLastRowNum + i + 1);        row.createCell(1).setCellValue(house.getTitle());        row.createCell(2).setCellValue(house.getTotalPrice());        row.createCell(3).setCellValue(house.getUnitPrice());        row.createCell(4).setCellValue(house.getVillage());        row.createCell(5).setCellValue(house.getStructure());        row.createCell(6).setCellValue(house.getAcreage());        row.createCell(7).setCellValue(house.getOrientation());        row.createCell(8).setCellValue(house.getDecoration());        row.createCell(9).setCellValue(house.getElevator());        row.createCell(10).setCellValue(house.getPosition());        row.createCell(11).setCellValue(house.getRegion());        row.createCell(12).setCellValue(house.getTag());        row.createCell(13).setCellValue(house.getUrl());      &#125;      FileOutputStream fileOut = new FileOutputStream(fileName);      workbook.write(fileOut);      IOUtils.closeQuietly(fileOut);      logger.info(\"文件&#123;&#125;写入完成,&#123;&#125;-&#123;&#125;行\", fileName, preLastRowNum + 1, preLastRowNum + houses.size());    &#125; catch (IOException e) &#123;      logger.error(\"excel-&#123;&#125;处理出错\", fileName, e);    &#125;    return fileName;  &#125;\n数据处理写入后核对数据没什么问题，然后需要对数据进行简单处理。  \n删除车位、别墅观察发现数据中有车位、别墅存在，不在我们投资范围，需要从类别中筛选出并删除\n重复数据小区名称中发现有如棕榈泉一期、棕榈泉二期、棕榈泉三期字样，我们此次的初步分析暂时不需要这样统计，在后期具体决策时再才需要参考某期是否离轻轨、学校更近，车位比更高等。所以也需要通过函数全部替换成“棕榈泉”。\n数据分析展现数据分析在多年拉卡拉、中汇支付风控、合规经验的老婆手把手教导下完成，大量运用透视图  \n小区平均单价分析初步数据处理后，不会再有总价500w这种不忍直视的内容，此时我们需要来个直观的小区平均单价柱状图冲击一下小区平均单价  \n\n\n\n类型\n平均单价（元）\n小区\n\n\n\n\n最高\n20,000\n比毕得豪园\n\n\n最低\n6,480\n人和家园\n\n\n平均\n14,151.46\n\n\n\n当然这个价格并不准确，其中有房龄、交通、装修、是否带学校指标等其它因素，但是至少可以让我们跨出第一步让自己对市场价格有一定的认知，计算自己可承受的价位\n房源数量分析接下来看看房源多的一些小区，经过我们之前处理过后不分几期几期后只取前20，分布如下棕榈泉的楼盘本身大房子数量多，且含有别墅洋房及高层，出售最多，占比27.32%力夺第二的9.02%。想必其中很多都是投资来的，如果分析清水与装修过的比例、持有房子年限等应该是可以分析出来   \n户型占比分析作为投资户型极其重要，市场上哪些户型受欢迎，新楼盘也一样会对人群分析，对楼盘人群定位。3室2厅大比分夺得冠军，4室2厅为第二出乎意料，应该具体分析这些房子的出处是否为棕榈泉的洋房。除去4室2厅外，3室2厅和2室2厅都在我们接受的范围，像我们没有多少财力的年轻人很多第一套房会选择2室2厅，够自己和孩子住，但是如果加入父母就不够住了，多半会卖掉换一个3室2厅。由此可以得出结论，如果目标为这些改善型的人群，3室2厅是最佳选择如果财力有限可以可以买2室2厅如果钱更少是否需要买个1室来投资出租，就该考虑地段及租金的关联关系了。  \n全国商品房销售面积分析2月3日对全国商品房销售面积抓取，制作简单折线图  \n其实还有很多可分析，想必房子的热门程度和价格是有一定关系，多久可以收回成本等。程序猿总是想太多，一个简单需求整成了一个价格监控、预测系统。所以本文只做简单分析，代码也很简单，2小时左右。源码Github:house\n","categories":["Data"],"tags":["Excel"]},{"title":"cq.qq.com","url":"/2015/10/06/cq-qq-com/","content":"国庆长假第三天：阴雨不断 影响出游\n\n大渝网新闻中心 重庆晨网  吴国富2015-10-04 07:20今年流行头上长花。重庆晨网记者 吴国富 摄\n国庆节假日进入第三天，重庆主城天气阴雨相间，一定程度上影响了市民出游，但对整个重庆全市旅游接待影响不大，旅游接待有升有降，总体平稳，重庆市旅游市场秩序良好，无旅游安全事故。\n（一）都市功能核心区和拓展区。渝中区接待95.1万人次，同比增长12.9%；沙坪坝区接待30.33万人次，同比增长6.78%；渝北区接待25.78万人次，同比增长10.54%；北碚区接待19.34万人次，同比增长7.86%；九龙坡区接待29.47万人次，同比下降2.9%。\n（二）城市发展新区。南川区接待5.1万人次，同比增长19%；大足区接待6.69万人次，同比增长41.7%；铜梁区接待17.27万人次，同比增长32.25%；江津区接待8.92万人次，同比增长16.4%；永川区接待13.38万人次，同比增长23.39%；合川区接待1.55万人次，同比下降15.3%。\n（三）渝东北生态涵养发展区。万州区接待17.18万人次，同比增长4.07%；巫山县接待4.73万人次，同比增长0.97%；奉节县接待1.74万人次，同比增长2.1%；云阳县接待10.03万人次，同比增长321%;梁平县接待3.62万人次，同比增长19.3%；丰都县接待2.69万人次，同比下降19.65%。\n（四）渝东南生态保护发展区。武隆县接待18.87万人次，同比增长15.67%；黔江区接待6.52万人次，同比增长20.29%；酉阳县接待5.11万人次，同比增长3.81%；石柱县接待2.93万人次，同比增长9.6%。\n3日离港班机共383架次，离港旅客共4.77万人次；入港班机384架次，入港旅客4.96万人次。铁路发送列车共164车次，发送旅客共13.5万人次；抵达列车164车次，抵达旅客11.8万人次。水运发送客船共26船班，发送旅客共0.33万人次；抵达客船26船班，抵达旅客0.26万人次。公路发送车次共7981班，发送旅客共21.61万人次；抵达车次7000班，抵达旅客20.99万人次。\n三、旅游适时信息友情提示\n各地旅游接待稳步上升，各区县旅游管理部门和旅游企业要认真按照《重庆市旅游局关于认真做好2015年国庆节假日旅游工作的通知》要求，结合天气和游客流量变化，加强旅游景区的安全监督检查和管理，落实相关旅游安全防范措施，加强应急值守，确保旅游安全。\n根据最新天气预报资料，4日，阴转小雨，气温18—21℃，西风微风。\n(重庆晨网)\n","categories":["Other"]},{"title":"日期格式化 YYYY日期错位","url":"/2018/01/03/date-formate-YYYY-in-java/","content":"起因支付系统通知账务还款结果时，对请求时间使用“YYYYMMddHHmmss”格式化，20171231变为了20181231致使数据不匹配。  \n我们大多都知道mm与MM的区别，因为分和月会同时出现，但很少会关注其它的pattern大小写有无区分。\n重现demo如下  \nDate date = new Date(2017 - 1900, 11, 31);\n\nDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);\nSystem.out.println(dateFormat.format(date));\n\ndateFormat = new SimpleDateFormat(&quot;YYYY-MM-dd&quot;);\nSystem.out.println(dateFormat.format(date));\n输出结果：2017-12-312018-12-31  \nDate and Time Patterns  \n\n\n\nLetter\nDate or Time Component\nPresentation\nExamples\n\n\n\n\nG\nEra designator\nText\nAD\n\n\ny\nYear\nYear\n1996; 96\n\n\nY\nWeek year\nYear\n2009; 09\n\n\nM\nMonth in year (context sensitive)\nMonth\nJuly; Jul; 07\n\n\nL\nMonth in year (standalone form)\nMonth\nJuly; Jul; 07\n\n\nw\nWeek in year\nNumber\n27\n\n\nW\nWeek in month\nNumber\n2\n\n\nD\nDay in year\nNumber\n189\n\n\nd\nDay in month\nNumber\n10\n\n\nF\nDay of week in month\nNumber\n2\n\n\nE\nDay name in week\nText\nTuesday; Tue\n\n\nu\nDay number of week (1 = Monday, …, 7 = Sunday)\nNumber\n1\n\n\na\nAm/pm marker\nText\nPM\n\n\nH\nHour in day (0-23)\nNumber\n0\n\n\nk\nHour in day (1-24)\nNumber\n24\n\n\nK\nHour in am/pm (0-11)\nNumber\n0\n\n\nh\nHour in am/pm (1-12)\nNumber\n12\n\n\nm\nMinute in hour\nNumber\n30\n\n\ns\nSecond in minute\nNumber\n55\n\n\nS\nMillisecond\nNumber\n978\n\n\nz\nTime zone\nGeneral time zone\nPacific Standard Time; PST; GMT-08:00\n\n\nZ\nTime zone\nRFC 822 time zone\n-0800\n\n\nX\nTime zone\nISO 8601 time zone\n-08; -0800; -08:00\n\n\n\n以上y为正常理解中的year，Y为week year，当天所在的周所属年份，一周从周日开始，周六结束。只要本周跨年，那么这周即算入下一年，2017-12-31为周日，刚好是2017最后一周并跨年。用YYYY获取自然得出2018，造成了这个错误。  \n参考SimpleDateFormat by JavaDate Formatters by iOS  \n","categories":["Java"],"tags":["DateFormat","YYYY"]},{"title":"Gson序列化、反序列化枚举","url":"/2020/01/08/enum-serializer-by-Gson/","content":"后端返回了N多枚举，前端Gson解析报错？后端接口返回很多枚举，Android复用实体，解析时却报错  \ncom.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected a string but was BEGIN_OBJECT at line 1 column 70 path $.data.type\n先定义一个枚举例子  Type.java  \npublic enum Type&#123;\tGSON(0, \"Gson\"),\tJACKSON(1, \"Jackson\"),\tFASTJSON(2, \"FastJson\");\tprivate final int code;\tprivate final String name;\t\tType(int code, String name)&#123;\t\tthis.code = code;\t\tthis.name = name;\t&#125;\t\tpublic static Type code(int code)&#123;\t\tfor (Type i : Type.values())&#123;\t\t\tif(i.code() == code)&#123;\t\t\t\treturn i;\t\t\t&#125;\t\t&#125;\t\treturn null;\t&#125;\t\tpublic static Type name(String name)&#123;\t\tfor (Type i : Type.values())&#123;\t\t\tif(i.name().equals(name))&#123;\t\t\t\treturn i;\t\t\t&#125;\t\t&#125;\t\treturn null;\t&#125;\t\tpublic int code()&#123;\t\treturn code;\t&#125;\t\tpublic String name()&#123;\t\treturn name;\t&#125;&#125;\n在序列化时服务端有两种试返回1、完整返回枚举\n&#123;\"type\":&#123;\"code\":0,\"name\":\"Gson\"&#125;&#125;\n2、序列化code或name\n&#123;\"type\":0&#125;//&#123;\"type\":\"Gson\"&#125;\n最好的解决办法——解决提出问题的人很不幸后端是我负责的，所以我们有三个解决方法1、让前端自己解决2、为前端提供技术方案3、修改后端枚举我应该怎么办？以上，当然是认怂，直接奉上代码喽Json是一种广泛使用的数据交换格式，在Java中序列化和反序列化的各API名称也都类似，下面正式介绍Gson如何序列化、反序列化枚举  \n\n实现JsonSerializer/JsonDeserializer序列化及反序列化如何实现实现JsonSerializer/JsonDeserializer，在序列化和反序列化时会调用重载的serialize、deserialize方法  \nimport com.google.gson.JsonDeserializationContext;import com.google.gson.JsonDeserializer;import com.google.gson.JsonElement;import com.google.gson.JsonObject;import com.google.gson.JsonParseException;import com.google.gson.JsonPrimitive;import com.google.gson.JsonSerializationContext;import com.google.gson.JsonSerializer;public class TypeSerializer implements JsonDeserializer&lt;Type&gt;, JsonSerializer&lt;Type&gt; &#123;  @Override public Type deserialize(JsonElement json, java.lang.reflect.Type typeOfT,      JsonDeserializationContext context) throws JsonParseException &#123;    //&#123;\"type\":&#123;\"code\":0,\"name\":\"Gson\"&#125;&#125;    /**    return Type.code(Integer.valueOf(((JsonObject) json).get(\"code\").toString()));    return Type.name(((JsonObject) json).get(\"name\").toString());     **/          //&#123;\"type\":0&#125;\t //&#123;\"type\":\"Gson\"&#125;    /**    return Type.code(json.getAsNumber());    return Type.name(json.getAsString());     **/    return null;  &#125;  @Override public JsonElement serialize(Type src, java.lang.reflect.Type typeOfSrc,      JsonSerializationContext context) &#123;      //&#123;\"type\":&#123;\"code\":0,\"name\":\"Gson\"&#125;&#125;    /**     JsonObject jsonObject = new JsonObject();     jsonObject.addProperty(\"code\", src.code());     jsonObject.addProperty(\"name\", src.name());     return jsonObject;     **/          //&#123;\"type\":0&#125;\t //&#123;\"type\":\"Gson\"&#125;    /**    JsonPrimitive jsonPrimitive = new JsonPrimitive(src.code());    JsonPrimitive jsonPrimitive = new JsonPrimitive(src.name());    return jsonPrimitive;     **/    return null;  &#125;&#125;\nregisterTypeAdapter还需要将上面的Serializer注册到Gson中  \nnew GsonBuilder()    .registerTypeAdapter(Type.class, new TypeSerializer())    .create();\n解析经过以上步骤后就解决了枚举序列化和反序列化问题gson.fromJson时遇到枚举Type类型会调用TypeSerializer中的serialize方法gson.toJson时遇到要解析枚举Type类型时会调用TypeSerializer中的deserialize方法\n","categories":["Java"],"tags":["Gson"]},{"title":"刷脸支付-人脸比对效率","url":"/2018/12/06/face-rec-algorithm/","content":"支付宝、微信刷脸支付时都要求先输入手机号，再刷人脸支付。马上刷脸付输入手机后4位，再刷脸认证支付。都刷脸了，为啥还要输入手机号，不如掏出手机扫一扫。极其不理想这个问题主要由目前人脸识别算法处理方式导致。我们基于传统业务想象中，应当是\n\n抓取人脸\n提取特征\n查询验证数据\n支付  \n\n如此，果然不再需要手机号。但是“基于人脸特征点的识别算法”，提取的特征并非是唯一数值可供直接比对查询。需要与所有特征点计算以匹配度最高来判断（1：N）。所以真实流程是1.抓取人脸2.提取特征3.查询所有用户特征计算4.获取最匹配数值与阈值比对5.支付如果输入了全的手机号后，就不再有耗时的1：N，而是1：1。以上\n推荐支付宝怎么敢采用后4位手机号人脸支付\n—  END  —分享程序员所看、所想、所悟、所望\n","categories":["Other"],"tags":["人脸支付"]},{"title":"301重定向导致不能正常访问","url":"/2017/12/07/fix-301-redirect/","content":"事件通报中称由于挂维护跳转301后，恢复服务，app WebView访问缓存仍然停留在公司官方网页，无法正确访问。参考Http Status Code Definitions究其原因可以知道默认情况下大家都必须遵守规范，才能不乱，并在这套规则中永久玩下去。如果遇到类似情况，直接分析请求头\n","categories":["Java"],"tags":["301","302","Http Status Code"]},{"title":"使用FeignClient上传文件","url":"/2019/11/22/feign-upload-file/","content":"问题使用FeignClient上传文件时居然失败了？意外，不敢相信SpringCloud中的组件不可能不支持该功能版本SpringCloud: Dalston.Releasefeign: 9.4.0  \n期间有各种报错，如：FileUploadException: the request was rejected because no multipart boundary was foundMissingServletRequestPartException: Required request part ‘file’ is not present  \n原因因为feign 9.4.0默认并不支持multipart/form（文件上传），需要手动引入feign-form、feign-form-spring  \n使用方式引入feign-form依赖 \n&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;    &lt;artifactId&gt;feign-form&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;io.github.openfeign.form&lt;/groupId&gt;    &lt;artifactId&gt;feign-form-spring&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n改造上传文件FeignClient\n@FeignClient(    name = \"file-upload-service\",    configuration = FileUploadServiceClient.MultipartSupportConfig.class)public interface FileUploadServiceClient extends IFileUploadServiceClient &#123;  public class MultipartSupportConfig &#123;    @Autowired    private ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;    @Bean    public Encoder feignFormEncoder () &#123;    \t// 支持文件上传FormEncoder及之前默认的其它Encoder      return new SpringFormEncoder(new SpringEncoder(messageConverters));    &#125;  &#125;&#125;\n到此已可用   \n不同版本选择上文中采用的feign-form版本是与feign版本是对应的。如果版本对应错误，是不兼容的。 \n\n\n\nspring-cloud\nfeign\nfeign-form\n\n\n\n\nDalston\n9.4.0\n3.5.0以前（20191122最新：3.4.1）\n\n\nGreenwich\n10.4.0\n3.5.0以后（20191122最新：3.8.0）\n\n\n\nMultipartFile接收时找不到问题MissingServletRequestPartException: Required request part ‘file’ is not present正常情况下可能是指定的文件名不对，其它的可能不谈，只谈我在使用过程中遇到问题用户端：  上传文件Server1：  接收用户上传文件Server2：  接收服务器端1上传文件1、Server2代码示例  \n@RequestMapping(value = \"upload\", method = RequestMethod.POST,        consumes = &#123;MediaType.MULTIPART_FORM_DATA_VALUE&#125;)@ResponseBodypublic void checkin(@RequestPart(\"file\") MultipartFile file) &#123;\t\t\t// do something&#125;\n2、Server1代码示例  \n@RequestMapping(value = \"upload\", method = RequestMethod.POST,        consumes = &#123;MediaType.MULTIPART_FORM_DATA_VALUE&#125;)@ResponseBodypublic RespBody checkin(@RequestPart(\"file1\") MultipartFile file1) &#123;\t\t\tServer2FeignClient.upload(file1);        return RespBody.ok();&#125;\nServer2FeignClient关键代码\nvoid upload(@RequestPart(\"file\") MultipartFile file);\n结果就是Server2可以接收到请求，但是收不到file文件，此时我们查看Server1中的MultipartFile对象发现，虽然已经在Server2FeignClient中设置MultipartFile 的key为file，但是Server2收到的仍然是file1。\n解决方法:  通过反映方式将MultipartFile的fieldName改为Server2需要的key\nField partField = multipartFile.getClass().getDeclaredField(\"part\");partField.setAccessible(true);ApplicationPart part = (ApplicationPart) partField.get(multipartFile);Field fileItemField = part.getClass().getDeclaredField(\"fileItem\");fileItemField.setAccessible(true);org.apache.tomcat.util.http.fileupload.disk.DiskFileItem fileItem = (org.apache.tomcat.util.http.fileupload.disk.DiskFileItem) fileItemField.get(part);fileItem.setFieldName(\"file\");\n引用https://github.com/OpenFeign/feign-form\n","categories":["Java"],"tags":["FeignClient"]},{"title":"修复X转换Time Zone出错问题","url":"/2019/05/16/fix-Unknown-pattern-character-x/","content":"IllegalArgumentException Unknown pattern character ‘x’, when using SimpleDateFormat\n代码如下：try &#123;  new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ssX\").parse(\"2019-05-14T19:00:11+08:00\");&#125; catch (ParseException e) &#123;  e.printStackTrace();&#125;在Android 8.0运行没问题，但在5.1及以下会抛“IllegalArgumentException Unknown pattern character ‘x’, when using SimpleDateFormat”，如此看来基本可以认为是版本兼容问题\n\n首先我们查找文档对于格式化定义，之前文章日期格式化YYYY日期错位中有提到Java中Date and Time Patterns，下面我们再看看Android中java.txt.SimpleDateFormat中的Date and Time Patterns\nDate and Time Patterns  \n\n\n\nSymbol\nMeaning\nKind\nExample\n\n\n\n\nD\nDay in year\nNumber\n189\n\n\nE\nDay of week\nText\nE/EE/EEE:Tue,EEEE:Tuesday,EEEEE:T\n\n\nF\nDay of week in month\nNumber\n2(2nd Wed inJuly)\n\n\nG\nEra designator\nText\nAD\n\n\nH\nHour in day (0-23)\nNumber\n0\n\n\nK\nHour in am/pm (0-11)\nNumber\n0\n\n\nL\nstand-alone month\nText\nL:1 LL:01 LLL:Jan LLLL:January LLLLL:J\n\n\nM\nMonth in year\nText\nM:1 MM:01 MMM:Jan MMMM:January MMMMM:J\n\n\nS\nfractional seconds\nNumber\n978\n\n\nW\nWeek in month\nNumber\n2\n\n\nZ\ntime zone (RFC 822)\ntime zone\nZ/ZZ/ZZZ:-0800 ZZZZ:GMT-08:00 ZZZZZ:-08:00\n\n\na\nAm/pm marker\nText\nPM\n\n\nc\nstand-alone day of week\nText\nc/cc/ccc:Tue, cccc:Tuesday, ccccc:T\n\n\nd\nDay in month\nNumber\n10\n\n\nh\nHour in am/pm (1-12)\nNumber\n12\n\n\nk\nHour in day (1-24)\nNumber\n24\n\n\nm\nMinute in hour\nNumber\n30\n\n\ns\nSecond in minute\nNumber\n55\n\n\nw\nWeek in year\nNumber\n27\n\n\ny\nYear\nNumber\nyy:10 y/yyy/yyyy:2010\n\n\nz\ntime zone\nTime Zone\nz/zz/zzz:PST zzzz:Pacific Standard Time\n\n\n‘\nescape for text\nDelimiter\n‘Date=’:Date=\n\n\n‘ ‘\nsingle quote\nLiteral\n‘o’’clock’:o’clock\n\n\n\n从中我们看到X和Z都是time zone，改成Z即可。Android中的SimpleDateFormat也是使用Java的apiAndroid 5.0开始采用了JDK 7，对应应该已经有X了，见SimpleDateFormat但是我们从Android 22的源码中可以看到public class SimpleDateFormat extends DateFormat &#123;    private static final long serialVersionUID = 4774881970558875024L;    // 'L' and 'c' are ICU-compatible extensions for stand-alone month and stand-alone weekday.    static final String PATTERN_CHARS = \"GyMdkHmsSEDFwWahKzZLc\";    // The index of 'Z' in the PATTERN_CHARS string. This pattern character is supported by the RI,    // but has no corresponding public constant.    private static final int RFC_822_TIMEZONE_FIELD = 18;    // The index of 'L' (cf. 'M') in the PATTERN_CHARS string. This is an ICU-compatible extension    // necessary for correct localization in various languages (http://b/2633414).    private static final int STAND_ALONE_MONTH_FIELD = 19;    // The index of 'c' (cf. 'E') in the PATTERN_CHARS string. This is an ICU-compatible extension    // necessary for correct localization in various languages (http://b/2633414).    private static final int STAND_ALONE_DAY_OF_WEEK_FIELD = 20;    private String pattern;    private DateFormatSymbols formatData;\nAndroid 28public class DateFormatSymbols implements Serializable, Cloneable &#123;...    /**     * Unlocalized date-time pattern characters. For example: 'y', 'd', etc.     * All locales use the same these unlocalized pattern characters.     */    // Android-changed: Add 'c' (standalone day of week), 'b' (day period),    //   'B' (flexible day period)    static final String  patternChars = \"GyMdkHmsSEDFwWahKzZYuXLcbB\";\n重点：static final String PATTERN_CHARS = “GyMdkHmsSEDFwWahKzZLc”;static final String  patternChars = “GyMdkHmsSEDFwWahKzZYuXLcbB”;\n源码里可以看到导致问题原因，但是为何Android 22中的java代码与Java 7中不一致呢？\n","categories":["Android"],"tags":["SimpleDateFormat","Time Zone"]},{"title":"Android正确获取IP及MAC","url":"/2017/04/06/get-correct-ip-address/","content":"每个产品都会统计用户终端信息。稍不注意就会经我们的手造成公司得到的数据错误，造成分析甚至战略错误。（假装是程序猿缔造了世界）  \n设备：Oppo R9s、vivo X9系统：Android 6.0.2网络：4G错误IP和MAC分别为  \nfe80::188c:24ff:fe49:8e54%dummy002:00:00:00:00:00\n\n错误代码：public static String getLocalIpAddress() &#123;  try &#123;    for (        Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();        networkInterfaces.hasMoreElements(); ) &#123;      NetworkInterface networkInterface = networkInterfaces.nextElement();      for (Enumeration&lt;InetAddress&gt; inetAddresses = networkInterface.getInetAddresses();          inetAddresses.hasMoreElements(); ) &#123;        InetAddress inetAddress = inetAddresses.nextElement();        if (!inetAddress.isLoopbackAddress()) &#123;          String ipAddress = inetAddress.getHostAddress().toUpperCase();          return ipAddress;        &#125;      &#125;    &#125;  &#125; catch (SocketException e) &#123;  &#125;  return null;&#125;\n然后根据搜索结果认为，直接将“%dummy0%2”去掉结果即为ipv6地址。不管你信不信反正当时我是信了，后来脑海里有一个声音时不时告诉我这不对，世界不是这样的。（程序猿后遗症）\n链路地址、回送地址(Link-local address、Loopback address)上面的代码中我们屏蔽了Loopback address。并且获得的fe80::188c:24ff:fe49:8e54确为IPv6，但是前缀为fe80::/64都是链路本地地址，不是我们真正想要的ip。IPv6几种地址类型、概念，详细见IPv6  \n解锁获取IP正确姿势经过上面度娘普及姿势得知Link-local address、Loopback address不是我们想要的IP，于是干掉它们，改造后代码如下（仅需要注意注释后面那一句）public static String getLocalIpAddress() &#123;  try &#123;    for (        Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();        networkInterfaces.hasMoreElements(); ) &#123;      NetworkInterface networkInterface = networkInterfaces.nextElement();      for (Enumeration&lt;InetAddress&gt; inetAddresses = networkInterface.getInetAddresses();          inetAddresses.hasMoreElements(); ) &#123;        InetAddress inetAddress = inetAddresses.nextElement();        //过滤Loopback address, Link-local address        if (!inetAddress.isLoopbackAddress() &amp;&amp; !inetAddress.isLinkLocalAddress()) &#123;          return inetAddress.getHostAddress();        &#125;      &#125;    &#125;  &#125; catch (SocketException e) &#123;  &#125;  return null;&#125;OPPO R9s Android 6.0.1运行结果：  \n\n\n\n类型\nIP\n\n\n\n\nwifi\n172.27.35.3\n\n\n流量\n100.58.248.64\n\n\n\n扩展-解锁6.0后获取正确MAC姿势dummy0、lo、p2p0、rev_rmnet0、rev_rmnet1、rev_rmnet2、rev_rmnet3、rmnet0、rmnet1、rmnet2、rmnet3、rmnet_smux0、sit0、wlan0等等，我们发现有很多这样的名称。我的理解是除了wlan0是与电脑一样的真实无线网卡外，其它全是虚拟网卡，用于内部通信。在6.0之后，Android 移除了对设备本地硬件标识符的编程访问权。使用WifiInfo.getMacAddress() 、BluetoothAdapter.getAddress() 返回值为常量02:00:00:00:00:00。有了上面通过Java api获取IP地址的经验，获取mac地址是否也可以在这里使用。上代码public static String getMac() &#123;  try &#123;    for (        Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();        networkInterfaces.hasMoreElements(); ) &#123;      NetworkInterface networkInterface = networkInterfaces.nextElement();      if (\"wlan0\".equals(networkInterface.getName())) &#123;        byte[] hardwareAddress = networkInterface.getHardwareAddress();        if (hardwareAddress == null || hardwareAddress.length == 0) &#123;          continue;        &#125;        StringBuilder buf = new StringBuilder();        for (byte b : hardwareAddress) &#123;          buf.append(String.format(\"%02X:\", b));        &#125;        if (buf.length() &gt; 0) &#123;          buf.deleteCharAt(buf.length() - 1);        &#125;        String mac = buf.toString();        return mac;      &#125;    &#125;  &#125; catch (SocketException e) &#123;    e.printStackTrace();  &#125;  return null;&#125;OPPO R9s Android 6.0.1运行结果：  \n\n\n\n代码类型\nMAC\n权限\n\n\n\n\nWifiInfo\n02:00:00:00:00:00\nandroid.permission.ACCESS_WIFI_STATE\n\n\nNetworkInterface\nB8:37:65:2D:23:ED\nandroid.permission.INTERNET\n\n\n\n这里面涉及到挺多网络知识，现在还是比较懵逼dummy0、lo、p2p0、rev_rmnet0、rev_rmnet1、rev_rmnet2、rev_rmnet3、rmnet0、rmnet1、rmnet2、rmnet3、rmnet_smux0、sit0到底咋回事儿？\n特别鸣谢大牛老张，前公司上司，全栈。最近搞了一个有些性感的产品图交硬件玩家，网络牛人莽哥\n参考：IPv6InetAddress API硬件标识符访问权\n","categories":["Android"],"tags":["ip","02:00:00:00:00:00"]},{"title":"gradle查看解决依赖问题-记录Butterknife8.5.1","url":"/2017/05/11/gradle-dependencies/","content":"相信每个人都遇到过重复引用库、冲突的问题。如support-v4、appcompat-v7、NineOldAndroids很容易被多次引用。前同事在临上线前打包遇到merg出错How fix?最近发现一个更快查看依赖问题方法  \n第一种快捷查看依赖问题命令\ngradle -q app:dependencies\n\n第二种各module逐步查看一个一个module检查过去没有，这时候就有可能是第三方库引用了，可是第三方库那么多，How do?头疼，先换个姿势找到哪两个jar导致重复。通过打开文件发现DisplayManagerCompat类属于哪两个jar包可以确定出问题的jar为support-compat-25.1.0和support-v4-22.2.0，我们自己有依赖compat、v4 22.2.0，现在要找出冲突的compat25.1是哪个库添加的（前戏太长，我们要直奔主题）。使用maven时可以查看依赖关系，没理由要取代maven的gradle不支持。  \n\ngradle projects先查看有哪些项目   \ngradle project:dependencies其中project指上面projects获得的project，如IMKit  gradle IMKit:dependencies从图中可以看到是butterknife8.5.1依赖了compat25.1.0。  \n\n解决办法添加exclude法 修改compile添加exclude后解决 compile (\"com.jakewharton:butterknife:8.5.1\") &#123;     exclude group : 'com.android.support' &#125;\nGrovvy脚本修改版本号方法在其存在冲突的module中的build.gradle文件中加入下面代码，原理就是通过遍历所有依赖，并修改指定库的版本号\n其中requested.group == ‘com.android.support’ com.android.support表示要修改的依赖库\ndetails.useVersion ‘27.1.1’    27.1.1表示要修改的版本号configurations.all &#123;    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;        def requested = details.requested        if (requested.group == 'com.android.support') &#123;            if (!requested.name.startsWith(\"multidex\")) &#123;                details.useVersion '27.1.1'            &#125;        &#125;    &#125;&#125;\n扩展\n强制指定低版本force同一个grop的库多个引用时，会自动取最版本最高的，即我们通过gradle dependencies查看后的标(*)或者 -&gt; 后的版本。但是我们有时候需要覆盖使用为低版本，应用场景，使用React Native时想指定‘com.android.support:appcompat-v7:23.0.1’可以修改为  \ncompile (\"com.android.support:appcompat-v7:23.0.1\") &#123;     force = true &#125;\n\n查看pom依赖关系可以通过gradle命令查看依赖关系，那么我们写在build.gradle里面的依赖关系一定也有地方指定。每个工程里面指定gradle，gradle查找依赖库。根据这个逻辑，查看项目文件夹下的.idea-&gt;libraries-&gt;butterknife_8_5_1.xml、support_compat_25_1_0.xml、support_v4_22_2_0.xml，其中butterknife_8_5_1.xml内容如下：\n&lt;component name=\"libraryTable\"&gt;  &lt;library name=\"butterknife-8.5.1\"&gt;    &lt;CLASSES&gt;      &lt;root url=\"file://$PROJECT_DIR$/regClientDoc/build/intermediates/exploded-aar/com.jakewharton/butterknife/8.5.1/res\" /&gt;      &lt;root url=\"jar://$PROJECT_DIR$/regClientDoc/build/intermediates/exploded-aar/com.jakewharton/butterknife/8.5.1/jars/classes.jar!/\" /&gt;    &lt;/CLASSES&gt;    &lt;JAVADOC /&gt;    &lt;SOURCES&gt;      &lt;root url=\"jar://$USER_HOME$/.gradle/caches/modules-2/files-2.1/com.jakewharton/butterknife/8.5.1/16724f486072e3ab970fc47ccff6f9013061fa6/butterknife-8.5.1-sources.jar!/\" /&gt;    &lt;/SOURCES&gt;  &lt;/library&gt;&lt;/component&gt;\n\n\n根据source文件上级目录进入，找到butterknife-8.5.1.pom文件，内容如下： \n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" xmlns=\"http://maven.apache.org/POM/4.0.0\"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.jakewharton&lt;/groupId&gt;  &lt;artifactId&gt;butterknife&lt;/artifactId&gt;  &lt;version&gt;8.5.1&lt;/version&gt;  &lt;packaging&gt;aar&lt;/packaging&gt;  &lt;name&gt;Butterknife&lt;/name&gt;  &lt;description&gt;Field and method binding for Android views.&lt;/description&gt;  &lt;url&gt;https://github.com/JakeWharton/butterknife/&lt;/url&gt;  &lt;licenses&gt;    &lt;license&gt;      &lt;name&gt;The Apache Software License, Version 2.0&lt;/name&gt;      &lt;url&gt;http://www.apache.org/licenses/LICENSE-2.0.txt&lt;/url&gt;      &lt;distribution&gt;repo&lt;/distribution&gt;    &lt;/license&gt;  &lt;/licenses&gt;  &lt;developers&gt;    &lt;developer&gt;      &lt;id&gt;jakewharton&lt;/id&gt;      &lt;name&gt;Jake Wharton&lt;/name&gt;    &lt;/developer&gt;  &lt;/developers&gt;  &lt;scm&gt;    &lt;connection&gt;scm:git:git://github.com/JakeWharton/butterknife.git&lt;/connection&gt;    &lt;developerConnection&gt;scm:git:ssh://git@github.com/JakeWharton/butterknife.git&lt;/developerConnection&gt;    &lt;url&gt;https://github.com/JakeWharton/butterknife/&lt;/url&gt;  &lt;/scm&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.jakewharton&lt;/groupId&gt;      &lt;artifactId&gt;butterknife-annotations&lt;/artifactId&gt;      &lt;version&gt;8.5.1&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.android.support&lt;/groupId&gt;      &lt;artifactId&gt;support-annotations&lt;/artifactId&gt;      &lt;version&gt;25.1.0&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- 罪魁祸首  --&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.android.support&lt;/groupId&gt;      &lt;artifactId&gt;support-compat&lt;/artifactId&gt;      &lt;version&gt;25.1.0&lt;/version&gt;      &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;&lt;/project&gt;\n可以看到其中有依赖support-compat25.1.0    \n\nexclude的其它用法  \n\n参考：Add Build DependenciesDependency ManagementGradle Task \n","categories":["Other"],"tags":["Gradle"]},{"title":"头文件和命名空间是否必须同时引用？","url":"/2019/01/11/headerfiles-namespace/","content":"c++中开始的两行一般为#include &lt;iostream&gt;using namespace std;但也可以使用std::cin方式显示指定namespace。那么不使用”using namespace std;”是否可以直接采用std::cin调用呢？试验后却发现会报错。    \n头文件iostream中定义了std namespace，如果不用using namespace std，则cin cout不可见？目前未搞懂，先记录iostream源码如下：// iostream standard header for Microsoft#pragma once#ifndef _IOSTREAM_#define _IOSTREAM_#ifndef RC_INVOKED#include &lt;istream&gt; #pragma pack(push,_CRT_PACKING) #pragma warning(push,3) #pragma push_macro(\"new\") #undef new_STD_BEGIN  #ifdef _M_CEE_PURE__PURE_APPDOMAIN_GLOBAL extern istream cin, *_Ptr_cin;__PURE_APPDOMAIN_GLOBAL extern ostream cout, *_Ptr_cout;__PURE_APPDOMAIN_GLOBAL extern ostream cerr, *_Ptr_cerr;__PURE_APPDOMAIN_GLOBAL extern ostream clog, *_Ptr_clog;__PURE_APPDOMAIN_GLOBAL extern wistream wcin, *_Ptr_wcin;__PURE_APPDOMAIN_GLOBAL extern wostream wcout, *_Ptr_wcout;__PURE_APPDOMAIN_GLOBAL extern wostream wcerr, *_Ptr_wcerr;__PURE_APPDOMAIN_GLOBAL extern wostream wclog, *_Ptr_wclog;  #else /* _M_CEE_PURE */\t\t// OBJECTS__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 istream cin, *_Ptr_cin;__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream cout, *_Ptr_cout;__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream cerr, *_Ptr_cerr;__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 ostream clog, *_Ptr_clog;__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wistream wcin, *_Ptr_wcin;__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wostream wcout, *_Ptr_wcout;__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wostream wcerr, *_Ptr_wcerr;__PURE_APPDOMAIN_GLOBAL extern _CRTDATA2 wostream wclog, *_Ptr_wclog;\t\t// CLASS _Winitclass _CRTIMP2_PURE _Winit &#123;public:\t__thiscall _Winit();\t__thiscall ~_Winit() _NOEXCEPT;private:\t__PURE_APPDOMAIN_GLOBAL static int _Init_cnt;\t&#125;;  #endif /* _M_CEE_PURE */_STD_END #pragma pop_macro(\"new\") #pragma warning(pop) #pragma pack(pop)#endif /* RC_INVOKED */#endif /* _IOSTREAM_ *//* * Copyright (c) by P.J. Plauger. All rights reserved. * Consult your license regarding permissions and restrictions.V6.50:0009 */\n参考[C++]头文件(Header Files)和命名空间(Namespace)\n","categories":["C/C++"],"tags":["头文件","命名空间"]},{"title":"一个万能算法压缩所有图片？","url":"/2017/06/06/how-to-compress-image/","content":"图片越来越多，相素越来越高，导致越来越大的图片必然绕不开压缩。作为基础功能的图片压缩，本身问题却很多。如：  \n\nandroid压缩下来比iOS大，质量却低  \nh5压缩图片导致崩溃  \n微信号每天上传图片限制10w张  \n压缩后图片变形、不清晰各路大神提供了诸多解决方案，解决质量速度问题的libjpeg-turbo，android7.0之后也采用该库；解决裁剪问题的uCrop；压缩策略Luban；压缩质量、裁剪技术方案都是无需质疑选型使用就好。那么压缩策略呢？Luban（鲁班） —— Android图片压缩工具，仿微信朋友圈压缩策略。Luban可能是最接近微信朋友圈的图片压缩算法，有微信强大的用户量背书，我们是否可以在项目中直接使用该策略呢？答案是NO压缩策略其实与业务需求关系非常紧密。比如聊天时、展示文章等这个算法都特别合适，一般情况下该算法压缩出来的图片不大且可以被用户清晰辨识，如果看不清楚，可以点击下载查看原图。但是如果是拍证件，如身份证、银行卡这种就不需要。废话太多，写不下去了。总之，没有万能算法，要做的是分析自己的业务应用场景。\n\n","categories":["Android"],"tags":["libjpeg-turbo"]},{"title":"不动态创建链接情况下在Firebase Dynamic Link获取动态参数","url":"/2023/03/05/how-to-custom-parameter-in-Dynamic-Link/","content":"在使用Firebase的Dynamic Links做运营时，需要在链接中带去不同的参数，APP做不同的响应。如，在链接中带商品ID，用户点击不同链接进入不同商品详情页。Firebase中有两种方法可以实现。1、创建动态链接创建动态链接-简介2、通过动态链接参数来实现不创建动态链接APP接收自定义参数目的。缺点就是短链接变成了长链接。下面看看做实验的demo这是之前建立的链接我们希望在APP中获取参数，如title=How to custom parmeter the Dynamic LinkarticleLink=https://console.firebase.google.com/project/test-c67b6/durablelinks/details/https:~2F~2Fcustomparmeter.page.link~2F6SuK那我们需要在链接中给link添加想要加的参数\n效果链接：https://customparmeter.page.link/?link=https://blog.520wa.com?title=How to custom parmeter the Dynamic Link%26articleLink%3Dhttps%3A%2F%2Fconsole.firebase.google.com%2Fproject%2Ftest-c67b6%2Fdurablelinks%2Fdetails%2Fhttps%3A~2F~2Fcustomparmeter.page.link~2F6SuK&amp;apn=com.example.deeplinkAPP中获取结果：2023-03-04 22:57:32.532 12747-12747/com.example.deeplink W/com.example.deeplink.ComicActivity: getDynamicLink:onSuccess:https://blog.520wa.com?title=How+to+custom+parmeter+the+Dynamic+Link&amp;articleLink=https://console.firebase.google.com/project/test-c67b6/durablelinks/details/https:~2F~2Fcustomparmeter.page.link~2F6SuK\n注：link后的参数需要通过URLEncode编码，否则不能正确获取参数。不能是另一个动态链接\n","categories":["Android"],"tags":["Dynamic Links","动态参数"]},{"title":"如何预估MySQL表空间占用大小","url":"/2024/05/29/how-to-estimate-size-of-table-in-mysql/","content":"我们经常需要知道表空间大小，在修改表结构的时候需要知道表空间大小以预估影响时间；在设计表的时候需要预估表的数据量，预估磁盘空间等。\n查看已存在的表空间大小MySQL中information_schema有记录SELECT concat(round(sum((data_length+index_length)/1024/1024),2),'MB' as dataFROM information_schema.tablesWHERE table_schema='mydb' and table_name='mytable';\n新建表空间大小测算从上面可以看到表空间大小由数据大小+索引大小两部分组成下面通过一个例子来实际测算一下DDLmysql&gt; desc City;+-------------+----------+------+-----+---------+----------------+| Field       | Type     | Null | Key | Default | Extra          |+-------------+----------+------+-----+---------+----------------+| ID          | int(11)  | NO   | PRI | NULL    | auto_increment || Name        | char(35) | NO   |     |         |                || CountryCode | char(3)  | NO   | MUL |         |                || District    | char(20) | NO   |     |         |                || Population  | int(11)  | NO   |     | 0       |                |+-------------+----------+------+-----+---------+----------------+\n\n数据大小测算根据表结构中字段大小来测算66 bytes per row of data（4+35+3+20+4）\n\n索引大小测算4 bytes per row for the primary key7 bytes per row for country code index\n\n3 bytes for the country\n4 bytes for Clustered Key attached to the country code\n\n\n\n这不考虑BTREE或表空间碎片的内务管理对于一百万行，这将是77000000字节（73.43 MB）\n参考How to estimate/predict data size and index size of a table in MySQL\n更详细的还需要看InnoDB : Tablespace Space Management\n","categories":["Data"]},{"title":"如何生成requirements.txt","url":"/2024/03/27/how-to-gen-requirements-with-python/","content":"写了一个简单的python项目，希望生成一个requirements.txt文件方便在Github或其他地方运行安装依赖。作为新手我首先是一个一个从import里面去找到写到文件中的，结果发现居然会报错。后面找到一个工具pipreqs可以自动识别出项目中用到的所有依赖生成requirements.txt文件\nHowInstallationpip install pipreqs\nUsage$ pipreqs /home/project/locationSuccessfully saved requirements file in /home/project/location/requirements.txt\n生成requirements.txt内容如wheel==0.23.0Yarg==0.1.9docopt==0.6.2\n更详细的参数用法参照pipreqs Usage\n","categories":["Other"],"tags":["python"]},{"title":"设置，你所不知道的权限","url":"/2019/05/09/how-to-request-other-permissions/","content":"我们知道Android中权限分为 normal, dangerous，其实官方介绍中还有signature and special   \n正常权限，对用户风险小，声明后系统会在安装时自动授予该应用该权限。不提示用户授予正常权限，用户无法撤消这些权限。\n危险权限，涉及用户隐私，需要用户授权。且用户授权后也可以再修改拒绝。所以每次使用危险权限时都得先检查用户是否赋予该权限。\n签名权限则是相同签名的应用可以使用。\n特殊权限，与正常、危险权限不同，特别敏感。SYSTEM_ALERT_WINDOW、WRITE_SETTINGS\n\n以上需要的权限都在权限列表内，声明，检查即可。\n前几天gayhub群友贴了一张图问这个通知权限在哪里设置的\n\nWHAT，什么意思？如果拒绝用户就收不到应用的推送了吗？\n必须收不到，或者说不会显示。但是官方权限列表中却没有对应允许通知的权限。从中发现部份不在权限列表中，仍然严重影响我们APP体验的设置。如：允许通知、省电优化等\n这样的设置，官方为部份提供了API检测是否已设置。且只能引导用户设置，没有提供API让用户一键设置。\n允许通知\n检测是否开始允许通知权限\nNotificationManagerCompat 中的 areNotificationsEnabled()\n跳转允许通知设置界面\nSettings.ACTION_APP_NOTIFICATION_SETTINGS\n另外还有版本、机型兼容问题，需要自行研究和搜索\n下面的后台运行则只能通过引导用户设置，而没有检测API\n\n","categories":["Android"],"tags":["权限"]},{"title":"怎样使用DataX将HBase数据导入到MySQL","url":"/2023/08/04/how-to-hbase-to-mysql-on-datax/","content":"有需求使用DataX将HBase表中数据迁移到MySQL中，有的表在Phoenix中定义，使用hbase20xsqlreader读取。有的没有在Phoenix中定义，数据是动态插入，列是不固定的。\n\nhbase20xsqlreader，读取Phoenix\nhbase11xreader，读取HBase\n\n不管读取HBase还是Phoenix都要求填写column，但是可以写sql占位，传进来。\n我这里由于业务原因就没有使用占位符的方式传递。\n现在的业务需求是我HBase横表迁移到MySQL纵表中。\n动态列中的列名有在MySQL表中记录，所以实现流程就是\n\nshell 脚本调用mysql读取出要在HBase中读取的列\n循环生成hbase11xreader读取-写入txt的DataX json\n调用DataX执行上面的json文件导出txt\n循环txt为每行加入MySQL要插入的列key\n生成读取txt，写入MySQL\n\n\n代码\n#!/bin/bash# MySQL连接信息DB_USER=\"\"DB_PASS=\"\"DB_HOST=\"\"DB_NAME=\"\"# 执行的SQL语句SQL_QUERY=\"SELECT columnKey,otherColumn FROM KV;\"# 执行SQL并将结果存储到关联数组result=($(mysql -u$&#123;DB_USER&#125; -p$&#123;DB_PASS&#125; -h$&#123;DB_HOST&#125; -D$&#123;DB_NAME&#125; -N -B -e \"$&#123;SQL_QUERY&#125;\"))# 遍历结果，生成文件for ((i=0; i&lt;$&#123;#result[@]&#125;; i+=2)); do    columnKey=$&#123;result[i]&#125;    otherColumn=$&#123;result[i+1]&#125;        # 生成JSON内容    json_content=\"&#123;        \\\"job\\\": &#123;            \\\"setting\\\": &#123;                \\\"speed\\\": &#123;                    \\\"channel\\\": 1                &#125;            &#125;,            \\\"content\\\": [                &#123;                    \\\"reader\\\": &#123;                        \\\"name\\\": \\\"hbase11xreader\\\",                        \\\"parameter\\\": &#123;                            \\\"hbaseConfig\\\": &#123;                                \\\"hbase.zookeeper.quorum\\\": \\\"localhost\\\"                            &#125;,                            \\\"table\\\": \\\"Table\\\",                            \\\"encoding\\\": \\\"utf-8\\\",                            \\\"mode\\\": \\\"normal\\\",                            \\\"column\\\": [                                &#123;                                    \\\"name\\\": \\\"cf: column1\\\",                                    \\\"type\\\": \\\"string\\\"                                &#125;,                               &#123;                                    \\\"name\\\": \\\"cf: column2\\\",                                    \\\"type\\\": \\\"date\\\",                                    \\\"format\\\":\\\"yyyy-MM-dd HH:mm:ss\\\"                                &#125;,                               &#123;                                    \\\"name\\\": \\\"cf: $&#123;columnKey&#125;\\\",                                    \\\"type\\\": \\\"string\\\"                                &#125;                            ],                            \\\"range\\\": &#123;                                \\\"startRowkey\\\": \\\"\\\",                                \\\"endRowkey\\\": \\\"\\\",                                \\\"isBinaryRowkey\\\": true                            &#125;                        &#125;                    &#125;,                    \\\"writer\\\": &#123;                        \\\"name\\\": \\\"txtfilewriter\\\",                        \\\"parameter\\\": &#123;                            \\\"path\\\": \\\"datax_trans_file/tmp\\\",                            \\\"fileName\\\": \\\"dataCustom_$&#123;columnKey&#125;_$&#123;otherColumn&#125;\\\",                            \\\"writeMode\\\": \\\"truncate\\\",                            \\\"fieldDelimiter\\\": \\\"|\\\"                        &#125;                    &#125;                &#125;            ]        &#125;    &#125;\"        # 将JSON内容写入文件    echo \"$json_content\" &gt; \"datax_trans_file/dataCustom_$&#123;columnKey&#125;_$&#123;otherColumn&#125;_2txt.json\"    # 执行datax 生成txt文件    dataxtool/datax/bin/datax.py datax_trans_file/dataCustom_$&#123;columnKey&#125;_$&#123;otherColumn&#125;_2txt.json         # 读出对应txt 插入统计编码和名称done# 列出txt文件列表 插入数据# 遍历指定目录下的匹配文件，并处理文件内容for file in datax_trans_file/tmp/dataCustom_*; do    if [[ -f \"$file\" ]]; then        # 提取otherColumn和columnKey        filename=$(basename \"$file\")        IFS=\"_\" read -ra parts &lt;&lt;&lt; \"$filename\"        columnKey=\"$&#123;parts[1]&#125;\"        otherColumn=\"$&#123;parts[2]&#125;\"          # 为每一行添加信息        while IFS= read -r line; do            echo \"$line|$columnKey|$otherColumn|1\"        done &lt; \"$file\" &gt; \"$file.tmp\"        # 将临时文件替换原文件        mv \"$file.tmp\" \"$file\"        echo \"Added info to: $file\"    fidone# 执行写入mysqldataxtool/datax/bin/datax.py datax_trans_file/dataCustom2mysql.json\n","categories":["Data"],"tags":["DataX","HBase","MySQL"]},{"title":"如何排查解决Communications link failure","url":"/2025/02/14/how-to-resolve-communications-link-failure/","content":"\n项目启动运行几小时后数据库连接异常，重启正常使用\n偶发数据库连接异常，重启正常使用\n偶发事物数据丢失\n\n怎么办，网上搜索，druid issue搜索，一会儿让改一下这个参数，一会儿改一下那个参数。各种改了重启，观察。然后报错依然复现存在。没想到我们也有资格成为调参工程师。\n环境\nMySQL：8.0.32\nDruid: 1.1.24\nDriver：mysql-connector 8.0.27\n\n错误异常通常错误有以下几种Caused by: java.net.SocketException: Connection resetCaused by: com.mysql.cj.exceptions.CJCommunicationsException: Communications link failureThe last packet successfully received from the server was 1,254,739 milliseconds ago. The last packet sent successfully to the server was 1,254,740 millisecond ago.s ago.Caused by: java.sql.SQLException: connection disabledat com.alibaba.druid.pool.DruidPooledConnection.checkStateInternal(DruidPooledConnection.java:1169)org.springframework.jdbc.UncategorizedSQLException:### Error querying database. Cause: java.sql.SQLException: connection disabledCause: java.sql.SQLException: connection disabled; uncategorized SQLException for SQL []; SQL state [null]; error code [0]; connection disabled; nested exception is java.sql.SQLException: connection disabled2025-02-11 04:46:31.300 ERROR 1 --- [http-nio-8080-exec-7] [c.a.druid.pool.DruidPooledStatement :368] : CommunicationsException, druid version 1.1.24, jdbcUrl : jdbc:mysql://host:3306/db?useUnicode=true&amp;characterEncoding=UTF8&amp;zroDateTimeBehavior=convertToNull&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10&amp;useSSL=false&amp;connectTimeout=10000&amp;socketTimeout=120000, testWhileIle true, idle millis 6403958, minIdle 5, poolingCount 2, timeBetweenEvictionRunsMillis 60000, lastValidIdleMillis 6403958, driver com.mysql.cj.jdbc.Driver, exeptionSorter com.alibaba.druid.pool.vendor.MySqlExceptionSorter2025-02-11 04:46:31.302 ERROR 1 --- [http-nio-8080-exec-7] [com.alibaba.druid.util.JdbcUtils :96] : close connection errorjava.sql.SQLNonTransientConnectionException: Communications link failure during rollback(). Transaction resolution unknown.\n排查步骤以上所有的错误都是指向连接异常。需要我们抽丝剥茧。杀人是个罪恶的行径，查出真相是我的责任。\n\n网络问题作为程序员首先想到的不是程序有问题出，而是环境有问题。是否有防火墙杀死应用到数据库的连接\n\n数据库超时时间设置问题查看数据库设置超时时间是否和druid配置不匹配查看数据库设置\nshow variables like '%timeout%';\n\n\n其中wait_timeout和interactive_timeout是设置MySQL在连接不操作多少秒后断开连接。如：客户端连接到MySQL超过8小时没有任何操作，则MySQL将主动断开连接。其中wait_timeout为非交互的连接，我们应用程序连接使用的就是这个。如果wait_timeout过小和druid配置连接检查间隔时间不合理，则有可能出现d以为该连接没关闭，但是MySQL已经主动关闭连接，导致连接异常的问题。但是这种情况较少，因为我们校验连接通常都是多少秒校验一次。另外MySQL参数中也有事务时间，应用程序有长事务，导致超过MySQL设置事务时间，会导致事务不成功  \n另外我们可以通过查询MySQL的连接来等待判断时间select * from information_schema.processlist where db = 'mydb'\n\ndruid配置不合理外部原因排查完后，就只剩下排查自己问题了。不对，也可以是druid提示不明显。我们通常将连接池托管给三方库，我们只需要按其提供建议配置就好。druid就是其中一种。各版本配置有些许变化，shardingsphere:props:sql-show: truequery-with-cipher-column: falsedatasource:names: salve,mastermaster:type: com.alibaba.druid.pool.DruidDataSourcedriverClassName: com.mysql.jdbc.Driverurl: jdbc:mysql://$&#123;db.host&#125;:$&#123;db.port&#125;/$&#123;db.database&#125;?useUnicode=true&amp;characterEncoding=UTF8&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10&amp;useSSL=false&amp;connectTimeout=10000&amp;socketTimeout=60000username: $&#123;db.username&#125;password: $&#123;db.password&#125;maxActive: $&#123;db.maxActive:100&#125;minIdle: $&#123;db.minIdle:5&#125;initialSize: $&#123;db.minIdle:5&#125;minEvictableIdleTimeMillis: $&#123;db.minEvictableIdleTimeMillis:180000&#125;maxEvictableIdleTimeMillis: $&#123;db.maxEvictableIdleTimeMillis:300000&#125;maxWait: $&#123;db.maxWait:10000&#125;maxWaitThreadCount: $&#123;db.maxWaitThreadCount:1000&#125;testOnBorrow: falsetestOnReturn: falsetestWhileIdle: truekeepAlive: truetimeBetweenEvictionRunsMillis: 20000validationQueryTimeout: 10validationQuery: SELECT 1## TRANSACTION_READ_COMMITTEDdefault-transaction-isolation: 2\n\n\n加入配置druid.mysql.usePingMethod=false在检查有效连接的时候才不会使用ping而使用validationQuery sql来检查另外可以查看DruidDataSource配置属性列表\n\n事务未正确关闭在排除了非程序问题，非配置问题后，还没有找到原因。就要想是不是druid的源码问题，还是MySQL源码问题。或者可能是自己程序哪里有问题。在看了一阵druid的源码和issue后发现有跟程序未正确结束事务（commit or rollback），会导致这个事务持有数据库连接无法正常归还到连接池，从而导致连接池中可用连接变少。我的问题就是这个，修改后，解决了这个连接异常问题issue\n\n","categories":["Data"],"tags":["MySQL","druid","CJCommunicationsException"]},{"title":"如何启动Phoenix Query Server","url":"/2023/08/03/how-to-start-phoenix-query-server/","content":"问题启动Phenix Query Server 6.0.0报错\n2023-08-03 15:20:01.672088 launching /var/jdk/bin/java -cp /etc/hbase/conf:/etc/hadoop/conf::/var/phoenix-queryserver-6.0.0/bin/../phoenix-queryserver-6.0.0.jar: -Dproc_phoenixserver -Dlog4j.configuration=file:/var/phoenix-queryserver-6.0.0/bin/log4j.properties -Dpsql.root.logger=INFO,DRFA -Dpsql.log.dir=/tmp/phoenix -Dpsql.log.file=phoenix-root-queryserver.log org.apache.phoenix.queryserver.server.QueryServer错误: 找不到或无法加载主类 org.apache.phoenix.queryserver.server.QueryServer\nHBase 2.4.15\nPhoenix 5.1.3\n前因升级HBase 2.4.15后，之前的Phoenix 4.13.1就不能用了。从Phoenix官网看到Phoenix和HBase的版本对应。\n\nCurrent release 4.16.1 can run on Apache HBase 1.3, 1.4, 1.5 and 1.6.Current release 5.1.3 can run on Apache HBase 2.1, 2.2, 2.3, 2.4 and 2.5.\n\n然后Phoenix 5.1.3中没有带query server，需要单独下载query server并启动，如图\n\n\n原因分析下载启动Phonex Query 6.0.0报了上面的错误\n找不到或无法加载主类报这种错，原因有可能是\n\nclass path路径不对\n\n子路径不匹配\n\nclass path缺少依赖\nclass-path需要你整个应用所有的依赖的class，也就是为了主类加载正确，JVM需要找到：\n\n主类本身；\n所有父亲类以及接口；\n所有声明变量的类以及调用的方法等\n\n\n\n查看上面的错误日志phoenix-queryserver-6.0.0.jar中是有org.apache.phoenix.queryserver.server.QueryServer的，可能的问题是class path缺少依赖\n修改日志级别，查看详细错误信息需要找到具体缺少了什么依赖，能否拿到详细报错信息辅助我们找到错误？\n启动命令中有log4j.properties -Dpsql.root.logger=INFO,\n我选择修改log3j.properties中的日志类型为DEBUG，再重新启动，查看日志，得到如下错误信息\n2023-08-03 15:28:01.024619 launching /var/jdk/bin/java -cp /etc/hbase/conf:/etc/hadoop/conf:/var/phoenix-queryserver-6.0.0/bin/../phoenix-client-hbase-2.4-5.1.3.jar:/var/phoenix-queryserver-6.0.0/bin/../phoenix-queryserver-6.0.0.jar: -Dproc_phoenixserver -Dlog4j.configuration=file:/var/phoenix-queryserver-6.0.0/bin/log4j.properties -Dpsql.root.logger=INFO,DRFA -Dpsql.log.dir=/tmp/phoenix -Dpsql.log.file=phoenix-root-queryserver.log  org.apache.phoenix.queryserver.server.QueryServerException in thread \"Thread-20\" java.lang.RuntimeException: java.io.FileNotFoundException: /var/phoenix-queryserver-6.0.0/phoenix-client-hbase-2.4-5.1.3.jar (没有那个文件或目录)        at org.apache.hadoop.conf.Configuration.loadResource(Configuration.java:3021)        at org.apache.hadoop.conf.Configuration.loadResources(Configuration.java:2968)        at org.apache.hadoop.conf.Configuration.getProps(Configuration.java:2848)        at org.apache.hadoop.conf.Configuration.get(Configuration.java:1200)        at org.apache.hadoop.conf.Configuration.getTrimmed(Configuration.java:1254)        at org.apache.hadoop.conf.Configuration.getBoolean(Configuration.java:1660)        at org.apache.hadoop.hbase.HBaseConfiguration.checkDefaultsVersion(HBaseConfiguration.java:69)        at org.apache.hadoop.hbase.HBaseConfiguration.addHbaseResources(HBaseConfiguration.java:83)        at org.apache.hadoop.hbase.HBaseConfiguration.create(HBaseConfiguration.java:97)        at org.apache.phoenix.query.ConfigurationFactory$ConfigurationFactoryImpl$1.call(ConfigurationFactory.java:49)        at org.apache.phoenix.query.ConfigurationFactory$ConfigurationFactoryImpl$1.call(ConfigurationFactory.java:46)        at org.apache.phoenix.util.PhoenixContextExecutor.call(PhoenixContextExecutor.java:76)        at org.apache.phoenix.util.PhoenixContextExecutor.callWithoutPropagation(PhoenixContextExecutor.java:90)        at org.apache.phoenix.query.ConfigurationFactory$ConfigurationFactoryImpl.getConfiguration(ConfigurationFactory.java:46)        at org.apache.phoenix.jdbc.PhoenixDriver$1.run(PhoenixDriver.java:77)Caused by: java.io.FileNotFoundException: /var/phoenix-queryserver-6.0.0/phoenix-client-hbase-2.4-5.1.3.jar (没有那个文件或目录)        at java.util.zip.ZipFile.open(Native Method)        at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:225)        at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:155)        at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:166)        at java.util.jar.JarFile.&lt;init&gt;(JarFile.java:103)        at sun.net.www.protocol.jar.URLJarFile.&lt;init&gt;(URLJarFile.java:93)        at sun.net.www.protocol.jar.URLJarFile.getJarFile(URLJarFile.java:69)        at sun.net.www.protocol.jar.JarFileFactory.get(JarFileFactory.java:99)        at sun.net.www.protocol.jar.JarURLConnection.connect(JarURLConnection.java:122)        at sun.net.www.protocol.jar.JarURLConnection.getInputStream(JarURLConnection.java:152)        at org.apache.hadoop.conf.Configuration.parse(Configuration.java:2943)        at org.apache.hadoop.conf.Configuration.getStreamReader(Configuration.java:3037)        at org.apache.hadoop.conf.Configuration.loadResource(Configuration.java:2995)        ... 14 more2023-08-03 17:44:55.845183 launching /var/jdk/bin/java -cp /etc/hbase/conf:/etc/hadoop/conf::/var/phoenix-queryserver-6.0.0/bin/../phoenix-queryserver-6.0.0.jar: -Dproc_phoenixserver -Dlog4j.configuration=file:/var/phoenix-queryserver-6.0.0/bin/log4j.properties -Dpsql.root.logger=INFO,DRFA -Dpsql.log.dir=/tmp/phoenix -Dpsql.log.file=phoenix-root-queryserver.log  org.apache.phoenix.queryserver.server.QueryServer错误: 找不到或无法加载主类 org.apache.phoenix.queryserver.server.QueryServer\n从上面日志，看到了错误问题，缺少phoenix-client-hbase-2.4-5.1.3.jar\n解决问题复制phoenix-client-hbase-2.4-5.1.3.jar从Phoenix 5.1.3目录下复制phoenix-client-hbase-2.4-5.1.3.jar到phoenix-queryserver-6.0.0的目录下\n启动Phoenix Query Serverbin/queryserver.py start\n启动成功\n[root@ump225 phoenix-queryserver-6.0.0]# bin/queryserver.py startstarting Query Server, logging to /tmp/phoenix/phoenix-root-queryserver.log[root@ump225 phoenix-queryserver-6.0.0]# tail -100f /tmp/phoenix/phoenix-root-queryserver.out2023-08-03 23:13:57.910434 launching /var/jdk/bin/java -cp /etc/hbase/conf:/etc/hadoop/conf:/var/phoenix-queryserver-6.0.0/bin/../phoenix-client-hbase-2.4-5.1.3.jar:/var/phoenix-queryserver-6.0.0/bin/../phoenix-queryserver-6.0.0.jar: -Dproc_phoenixserver -Dlog4j.configuration=file:/var/phoenix-queryserver-6.0.0/bin/log4j.properties -Dpsql.root.logger=INFO,DRFA -Dpsql.log.dir=/tmp/phoenix -Dpsql.log.file=phoenix-root-queryserver.log  org.apache.phoenix.queryserver.server.QueryServer\n总结如何启动Phoenix Query Server 6.0.0\n\n从Phoenix 5.1.3目录下复制phoenix-client-hbase-2.4-5.1.3.jar到phoenix-queryserver-6.0.0的目录下\n在Phoenix Query Server 6.0.0目录下执行bin/queryserver.py start\n查看日志/tmp/phoenix/phoenix-root-queryserver.out是否启动成功\n\n","categories":["Data"],"tags":["Phoenix Query Server 6.0.0"]},{"title":"Facebook广告中使用Deferred Deep Link","url":"/2023/04/06/how-to-use-Deferred-Deep-Link-in-Facebook/","content":"在运营时，学习使用了App Link和Deep Link，之前也使用了Firebase中的Dynamic Links在用户未安装App时跳转至Google Play安装后再打开仍然能获取到链接内容，带用户到推荐的个性化页面。后面由于运营需要在Facebook上做推广，需要接入Meta的Deep Link。运营时有3个场景，我们的App，以下简称A\n\n用户已安装A，点击Facebook广告链接，正常打开A并跳转至推广页面\n用户未安装A，点击Facebook广告链接，打开Google play store，下载安装，并在Google play store中点击打开，正常打开A并跳转至推广页面\n用户未安装A，点击Facebook广告链接，打开Google play store，下载安装，回到桌面点击A，正常打开A并跳转至推广页面实现1，只需要实现Meta中的Deep Link实现2、3则需要在实现Deep Link的基础外加上Deferred Deep Link\n注意AppLinkData.fetchDeferredAppLinkData\n需要在已启动的Activity中执行才能获得结果。即&lt;activity    android:name&#x3D;&quot;.SplashActivity&quot;&gt;    &lt;intent-filter&gt;        &lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot; &#x2F;&gt;        &lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot; &#x2F;&gt;    &lt;&#x2F;intent-filter&gt;&lt;&#x2F;activity&gt;&lt;activity    android:name&#x3D;&quot;.DeepLinkActivity&quot;    android:exported&#x3D;&quot;true&quot; &gt;    &lt;intent-filter android:autoVerify&#x3D;&quot;true&quot;&gt;        &lt;action android:name&#x3D;&quot;android.intent.action.VIEW&quot; &#x2F;&gt;        &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot; &#x2F;&gt;        &lt;category android:name&#x3D;&quot;android.intent.category.BROWSABLE&quot; &#x2F;&gt;        &lt;data android:scheme&#x3D;&quot;https&quot;            android:host&#x3D;&quot;blog.520wa.com&quot;&#x2F;&gt;        &lt;data            android:host&#x3D;&quot;520wa&quot;            android:scheme&#x3D;&quot;blog&quot;            android:pathPrefix&#x3D;&quot;&#x2F;lunch&quot;            &#x2F;&gt;    &lt;&#x2F;intent-filter&gt;&lt;&#x2F;activity&gt;\n在2、3的情况下，无法触达DeepLinkActivity，并执行DeepLinkActivity中的AppLinkData.fetchDeferredAppLinkData方法获取延迟深度链接。需要将AppLinkData.fetchDeferredAppLinkData放到SplashActivity中。且AppLinkData.fetchDeferredAppLinkData只能调1次\n\n参考App深度链接与延迟深度链接\n","categories":["Android"],"tags":["Deferred Deep Link"]},{"title":"什么是Redis keyspace notification","url":"/2023/10/06/keyspace-notifications/","content":"Redis消息架构两种中的一种keyspace notification、  Pub/Sub\n实时监控Rdis 键值改变。\nKeyspace通知允许client订阅Pub/Sub channels，以便接收影响Redis数据的事件。\n功能概览键空间通知使得客户端可以通过订阅频道或模式， 来接收那些以某种方式改动了 Redis 数据集的事件。\n以下是一些键空间通知发送的事件的例子：\n\n所有修改键的命令。\n所有接收到 LPUSH 命令的键。\n0 号数据库中所有已过期的键。\n\n事件通过 Redis 的订阅与发布功能（pub/sub）来进行分发， 因此所有支持订阅与发布功能的客户端都可以在无须做任何修改的情况下， 直接使用键空间通知功能。\n因为 Redis 目前的订阅与发布功能采取的是发送即忘（fire and forget）策略， 所以如果你的程序需要可靠事件通知（reliable notification of events）， 那么目前的键空间通知可能并不适合你： 当订阅事件的客户端断线时， 它会丢失所有在断线期间分发给它的事件。\n未来将会支持更可靠的事件分发， 这种支持可能会通过让订阅与发布功能本身变得更可靠来实现， 也可能会在 Lua 脚本中对消息（message）的订阅与发布进行监听， 从而实现类似将事件推入到列表这样的操作。\n\n事件的类型对于每个修改数据库的操作，键空间通知都会发送两种不同类型的事件。\n比如说，对 0 号数据库的键 mykey 执行 DEL 命令时， 系统将分发两条消息， 相当于执行以下两个 PUBLISH 命令：\nPUBLISH __keyspace@0__:mykey delPUBLISH __keyevent@0__:del mykey\n订阅第一个频道 __keyspace@0__:mykey 可以接收 0 号数据库中所有修改键 mykey 的事件， 而订阅第二个频道 __keyevent@0__:del 则可以接收 0 号数据库中所有执行 del 命令的键。\n以 keyspace 为前缀的频道被称为键空间通知（key-space notification）， 而以 keyevent 为前缀的频道则被称为键事件通知（key-event notification）。\n当 del mykey 命令执行时：\n键空间频道的订阅者将接收到被执行的事件的名字，在这个例子中，就是 del 。键事件频道的订阅者将接收到被执行事件的键的名字，在这个例子中，就是 mykey 。\n配置因为开启键空间通知功能需要消耗一些 CPU ， 所以在默认配置下， 该功能处于关闭状态。\n可以通过修改 redis.conf 文件， 或者直接使用 CONFIG SET 命令来开启或关闭键空间通知功能：\n当 notify-keyspace-events 选项的参数为空字符串时，功能关闭。另一方面，当参数不是空字符串时，功能开启。notify-keyspace-events 的参数可以是以下字符的任意组合， 它指定了服务器该发送哪些类型的通知：\n\n\n\n字符\n发送的通知\n\n\n\n\nK\n键空间通知，所有通知以 __keyspace@&lt;db&gt;__ 为前缀\n\n\nE\n键事件通知，所有通知以 __keyevent@&lt;db&gt;__ 为前缀\n\n\ng\nDEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知\n\n\n$\n字符串命令的通知\n\n\nl\n列表命令的通知\n\n\ns\n集合命令的通知\n\n\nh\n哈希命令的通知\n\n\nz\n有序集合命令的通知\n\n\nx\n过期事件：每当有过期键被删除时发送\n\n\ne\n驱逐(evict)事件：每当有键因为 maxmemory 政策而被删除时发送\n\n\nA\n参数 g$lshzxe 的别名\n\n\n\n输入的参数中至少要有一个 K 或者 E ， 否则的话， 不管其余的参数是什么， 都不会有任何通知被分发。\n举个例子， 如果只想订阅键空间中和列表相关的通知， 那么参数就应该设为 Kl ， 诸如此类。\n将参数设为字符串 “AKE” 表示发送所有类型的通知。\n命令产生的通知以下列表记录了不同命令所产生的不同通知：\n\nDEL 命令为每个被删除的键产生一个 del 通知。\nRENAME 产生两个通知：为来源键（source key）产生一个 rename_from 通知，并为目标键（destination key）产生一个 rename_to 通知。\nEXPIRE 和 EXPIREAT 在键被正确设置过期时间时产生一个 expire 通知。当 EXPIREAT 设置的时间已经过期，或者 - EXPIRE 传入的时间为负数值时，键被删除，并产生一个 del 通知。\nSORT 在命令带有 STORE 参数时产生一个 sortstore 事件。如果 STORE 指示的用于保存排序结果的键已经存在，那么程序还会发送一个 del 事件。\nSET 以及它的所有变种（SETEX 、 SETNX 和 GETSET）都产生 set 通知。其中 SETEX 还会产生 expire 通知。\nMSET 为每个键产生一个 set 通知。\nSETRANGE 产生一个 setrange 通知。\nINCR 、 DECR 、 INCRBY 和 DECRBY 都产生 incrby 通知。\nINCRBYFLOAT 产生 incrbyfloat 通知。\nAPPEND 产生 append 通知。\nLPUSH 和 LPUSHX 都产生单个 lpush 通知，即使有多个输入元素时，也是如此。\nRPUSH 和 RPUSHX 都产生单个 rpush 通知，即使有多个输入元素时，也是如此。\nRPOP 产生 rpop 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 通知。\nLPOP 产生 lpop 通知。如果被弹出的元素是列表的最后一个元素，那么还会产生一个 del 通知。\nLINSERT 产生一个 linsert 通知。\nLSET 产生一个 lset 通知。\nLTRIM 产生一个 ltrim 通知。如果 LTRIM 执行之后，列表键被清空，那么还会产生一个 del 通知。\nRPOPLPUSH 和 BRPOPLPUSH 产生一个 rpop 通知，以及一个 lpush 通知。两个命令都会保证 rpop 的通知在 lpush 的通知之前分发。如果从键弹出元素之后，被弹出的列表键被清空，那么还会产生一个 del 通知。\nHSET 、 HSETNX 和 HMSET 都只产生一个 hset 通知。\nHINCRBY 产生一个 hincrby 通知。\nHINCRBYFLOAT 产生一个 hincrbyfloat 通知。\nHDEL 产生一个 hdel 通知。如果执行 HDEL 之后，哈希键被清空，那么还会产生一个 del 通知。\nSADD 产生一个 sadd 通知，即使有多个输入元素时，也是如此。\nSREM 产生一个 srem 通知，如果执行 SREM 之后，集合键被清空，那么还会产生一个 del 通知。\nSMOVE 为来源键（source key）产生一个 srem 通知，并为目标键（destination key）产生一个 sadd 事件。\nSPOP 产生一个 spop 事件。如果执行 SPOP 之后，集合键被清空，那么还会产生一个 del 通知。\nSINTERSTORE 、 SUNIONSTORE 和 SDIFFSTORE 分别产生 sinterstore 、 sunionostore 和 sdiffstore 三种通知。如果用于保存结果的键已经存在，那么还会产生一个 del 通知。\nZINCRBY 产生一个 zincr 通知。（译注：非对称，请注意。）\nZADD 产生一个 zadd 通知，即使有多个输入元素时，也是如此。\nZREM 产生一个 zrem 通知，即使有多个输入元素时，也是如此。如果执行 ZREM 之后，有序集合键被清空，那么还会产生一个 del 通知。\nZREMRANGEBYSCORE 产生一个 zrembyscore 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 del 通知。\nZREMRANGEBYRANK 产生一个 zrembyrank 通知。（译注：非对称，请注意。）如果用于保存结果的键已经存在，那么还会产生一个 del 通知。\nZINTERSTORE 和 ZUNIONSTORE 分别产生 zinterstore 和 zunionstore 两种通知。如果用于保存结果的键已经存在，那么还会产生一个 del 通知。\n每当一个键因为过期而被删除时，产生一个 expired 通知。\n每当一个键因为 maxmemory 政策而被删除以回收内存时，产生一个 evicted 通知。\n\nNote\n所有命令都只在键真的被改动了之后，才会产生通知。\n比如说，当 SREM 试图删除不存在于集合的元素时，删除操作会执行失败，因为没有真正的改动键，所以这一操作不会发送通知。\n如果对命令所产生的通知有疑问， 最好还是使用以下命令， 自己来验证一下：\n$ redis-cli config set notify-keyspace-events KEA$ redis-cli --csv psubscribe '__key*__:*'Reading messages... (press Ctrl-C to quit)\"psubscribe\",\"__key*__:*\",1\n然后， 只要在其他终端里用 Redis 客户端发送命令， 就可以看到产生的通知了：\n\"pmessage\",\"__key*__:*\",\"__keyspace@0__:foo\",\"set\"\"pmessage\",\"__key*__:*\",\"__keyevent@0__:set\",\"foo\"...\n过期通知的发送时间Redis 使用以下两种方式删除过期的键：\n\n当一个键被访问时，程序会对这个键进行检查，如果键已经过期，那么该键将被删除。\n底层系统会在后台渐进地查找并删除那些过期的键，从而处理那些已经过期、但是不会被访问到的键。\n\n当过期键被以上两个程序的任意一个发现、 并且将键从数据库中删除时， Redis 会产生一个 expired 通知。\nRedis 并不保证生存时间（TTL）变为 0 的键会立即被删除： 如果程序没有访问这个过期键， 或者带有生存时间的键非常多的话， 那么在键的生存时间变为 0 ， 直到键真正被删除这中间， 可能会有一段比较显著的时间间隔。\n因此， Redis 产生 expired 通知的时间为过期键被删除的时候， 而不是键的生存时间变为 0 的时候。\n参考键空间通知（keyspace notification）)Redis keyspace notifications\n","categories":["Data"],"tags":["Redis"]},{"title":"手机资费套餐","url":"/2024/05/10/mobile-tariff-package/","content":"想找一个全网最低的资费套餐，网上也有0月租的，但是没有验证。从工信部查询出44个运营商官网拿到资费信息筛选出6元及以下的套餐如下\n\n\n\n运营商\n月租/资费\n套餐名称\n套餐详情\n套餐URL\n\n\n\n\n阿里通信\n6\n亲心6元套餐\n60分钟国内语音国内接听免费国内语音0.15元/分钟国内流量2元/日/随心用当日有效国内短信0.1元/条赠送来电显示\nhttps://aliqin.aliyuncs.com/#/prod\n\n\n日日顺通信\n5\n顺意套餐\n①、国内语音拨打资费：0.15元/分钟；②、国内流量：0.2元/M；③、国内点到点短信：0.1元/条；④、来电显示5元/月；\nhttps://rrstel.com/businessHall/localpage/zifeizone.jsp\n\n\n丰信移动\n6\n丰信6元A卡\n1.月租6元/月，赠送来电显示，赠送60分钟国内语音2.国内语音：0.15元/分钟3.国内流量：1元包500M/日4.国内短/彩信：0.1元/条。\nhttp://www.phtion.com/account/index\n\n\n蓝猫移动\n3.9\n蓝猫标准流量卡\n\nhttps://www.lanmaomobile.com/?list_8/232.html\n\n\n朗玛移动\n6\n小象阳光卡6元\n语音：0分钟流量：0GB流量：0.1元/1M短信：0.1元/条语音：0.15元/分钟\nhttps://www.langma.cn/langma-jx\n\n\n天音移动\n6\n天音卡-联通版\n打电话0.15元/分钟上网流量0.2元/M短信0.1元/条彩信0.3元/条来电显示月租5元\nhttps://rrstel.com/businessHall/localpage/zifeizone.jsp\n\n\n普泰移动\n6\n普泰惠享卡\n\nhttps://rrstel.com/businessHall/localpage/zifeizone.jsp\n\n\n苏宁互联\n5\n至简套餐\n\nhttps://rrstel.com/businessHall/localpage/zifeizone.jsp\n\n\n电信\n5\n无忧卡\n适用范围：全部公众用户有效期限：2025年11月30日销售渠道：线下及线上渠道可售范围：全国可售，但受各省销售安排所限合约要求：不限制\nhttps://www.189.cn/cq/zfzq/#tList_4\n\n\n\n","categories":["Other"],"tags":["资费套餐"]},{"title":"MySQL数据类型字段占用空间","url":"/2023/09/03/mysql-storage-requirements/","content":"经常看到这种建表sql\nCREATE TABLE `table1` (  `id` int(10) NOT NULL AUTO_INCREMENT,  `name` varchar(50) DEFAULT NULL,  `status` int(2) DEFAULT '0',  `fileProtocol` tinyint(1) NOT NULL DEFAULT '0' ,  PRIMARY KEY (`id`)) ;\nsql中为每个字段都加上了长度限制，能限制住吗？存储数据时占用的空间又是多少呢？\n具体见Data Type Storage Requirements\n","categories":["Data"],"tags":["MySQL"]},{"title":"netlink","url":"/2023/10/07/netlink/","content":"什么是Netlink通信机制\nNetlink是linux提供的用于内核和用户态进程之间的通信方式。\n但是注意虽然Netlink主要用于用户空间和内核空间的通信，但是也能用于用户空间的两个进程通信。只是进程间通信有其他很多方式，一般不用Netlink。除非需要用到Netlink的广播特性时。\n那么Netlink有什么优势呢？\n一般来说用户空间和内核空间的通信方式有三种：/proc、ioctl、Netlink。而前两种都是单向的，但是Netlink可以实现双工通信。\nNetlink协议基于BSD socket和AF_NETLINK地址簇(address family)，使用32位的端口号寻址(以前称作PID)，每个Netlink协议(或称作总线，man手册中则称之为netlink family)，通常与一个或一组内核服务/组件相关联，如NETLINK_ROUTE用于获取和设置路由与链路信息、NETLINK_KOBJECT_UEVENT用于内核向用户空间的udev进程发送通知等。\nnetlink具有以下特点：\n\n支持全双工、异步通信(当然同步也支持)\n用户空间可使用标准的BSD socket接口(但netlink并没有屏蔽掉协议包的构造与解析过程，推荐使用libnl等第三方库)\n在内核空间使用专用的内核API接口\n支持多播(因此支持“总线”式通信，可实现消息订阅)\n在内核端可用于进程上下文与中断上下文\n\n没有Linux和C的基础是真看不懂这是啥玩意儿…\n","categories":["Other"],"tags":["Linux"]},{"title":"Node.js 版本管理-本地多个版本切换使用","url":"/2023/02/17/node-version-manager/","content":"在不同项目里依赖于不同Node.js版本，使用NVM（Node.js version manager）即可做到。\nNVM安装下载地址NVM for Windowsnvm  sh，支持Mac、Linux下面介绍Windows安装方法下载并安装\nNVM使用\n运行命令行窗口\n查看版本信息D:\\&gt;nvm -v1.1.10\n查看Node.js版本D:\\&gt;nvm list // 显示已安装Node.js版本，与nvm list installed相同D:\\&gt;nvm list available // 显示可下载安装的Node.js版本\nNode.js安装\nshell 安装\n\nD:\\&gt;nvm install 12.14.0 // 安装12.14.0版本Node.js\n有时候会安装不成功，此时可以手动下载\n\n手动安装\n\n下载需要的Node.js版本Node.js Releases解压到nvm目录并改名为(v版本号)此时查看已安装Node.js版本就已经有以上安装的版本了\n当前使用Node.js版本查看及切换D:\\&gt;nvm current // 查看当前使用Node.js版本D:\\&gt;nvm use 12.14.0 // 切换Node.js版本","categories":["Web"],"tags":["nvm","Node.js版本","hexo","0kb"]},{"title":"NDK Samples学习 [6-1] - camera之basic","url":"/2019/03/05/ndksamples-camera-basic/","content":"camera-basicREADME该项目演示如何使用c创建camera拍照、预览。\n\n最低要求：\n\nAndroid Studio 2.3.0+ ,NDK r15+\nAndroid-24+\n\n\n项目主要流程：\n\n获取权限\n初始化界面，NDKCamera、曝光度、感光度\n操作相机，调整曝光度、感光度预览；拍照保存\n\n\n\nCameraActivity.java\n\nCameraSeekBar 包装SeekBar用于调整相机预览的曝光度、感光度\n\nvoid setImmersiveSticky() {} //设置全屏显示public void RequestCamera() {} //请求权限，由c++调用public void EnableUI(final long[] params){}//由c++调用，并传入曝光度、感光度参数public void OnPhotoTaken(String fileName) {}//由c++调用，传入拍照图片路径native static void notifyCameraPermission(boolean granted);//权限变化后native static void TakePhoto();//调用c++拍照native void OnExposureChanged(long exposure);//调用c++调整曝光度native void OnSensitivityChanged(long sensitivity);//调用c++调整感光度native static void notifyCameraPermission(boolean granted);//通知c++权限变化\nandroid_main.cpp c主入口/* * SampleEngine global object */static CameraEngine* pEngineObj = nullptr;/* * 获取CameraEngine单例对象 */CameraEngine* GetAppEngine(void) &#123;  ASSERT(pEngineObj, \"AppEngine has not initialized\");  return pEngineObj;&#125;/** * 根据收到INIT_WINDOW/TERM_WINDOW事件创建或删除camera对象， * 使用NativeActivity的应用才会收到 */static void ProcessAndroidCmd(struct android_app* app, int32_t cmd) &#123;  CameraEngine* engine = reinterpret_cast&lt;CameraEngine*&gt;(app-&gt;userData);  switch (cmd) &#123;    // 窗口初始化    case APP_CMD_INIT_WINDOW:      if (engine-&gt;AndroidApp()-&gt;window != NULL) &#123;        engine-&gt;SaveNativeWinRes(ANativeWindow_getWidth(app-&gt;window),                                 ANativeWindow_getHeight(app-&gt;window),                                 ANativeWindow_getFormat(app-&gt;window));        // 请求权限，创建camera        engine-&gt;OnAppInitWindow();      &#125;      break;    // 窗口关闭    case APP_CMD_TERM_WINDOW:      // 删除camera      engine-&gt;OnAppTermWindow();      ANativeWindow_setBuffersGeometry(          app-&gt;window, engine-&gt;GetSavedNativeWinWidth(),          engine-&gt;GetSavedNativeWinHeight(), engine-&gt;GetSavedNativeWinFormat());      break;    // 窗口配改变    case APP_CMD_CONFIG_CHANGED:      engine-&gt;OnAppConfigChange();      break;    // 失去焦点    case APP_CMD_LOST_FOCUS:      break;  &#125;&#125;extern \"C\" void android_main(struct android_app* state) &#123;  CameraEngine engine(state);  pEngineObj = &amp;engine;  state-&gt;userData = reinterpret_cast&lt;void*&gt;(&amp;engine);  state-&gt;onAppCmd = ProcessAndroidCmd;  // loop waiting for stuff to do.  while (1) &#123;    // Read all pending events.    int events;    struct android_poll_source* source;    while (ALooper_pollAll(0, NULL, &amp;events, (void**)&amp;source) &gt;= 0) &#123;      // Process this event.      if (source != NULL) &#123;        source-&gt;process(state, source);      &#125;      // Check if we are exiting.      if (state-&gt;destroyRequested != 0) &#123;        LOGI(\"CameraEngine thread destroy requested!\");        engine.DeleteCamera();        pEngineObj = nullptr;        return;      &#125;    &#125;    pEngineObj-&gt;DrawFrame();  &#125;&#125;/** * 窗口初始化时调用，请求相机相关权限，并创建camera */void CameraEngine::OnAppInitWindow(void) &#123;  if (!cameraGranted_) &#123;    // 请求相机相关权限    RequestCameraPermission();    return;  &#125;  // 旋转角度  rotation_ = GetDisplayRotation();  // 创建camera  CreateCamera();  ASSERT(camera_, \"CameraCreation Failed\");  // 启用曝光度UI  EnableUI();  // 预览  cameraReady_ = true;  camera_-&gt;StartPreview(true);&#125;/** * Handle APP_CMD_TEMR_WINDOW */void CameraEngine::OnAppTermWindow(void) &#123;  cameraReady_ = false;  // 销毁camera  DeleteCamera();&#125;/** * Handle APP_CMD_CONFIG_CHANGED * 获取旋转角度 * 旋转角度有变化，销毁camera，再重新创建camera */void CameraEngine::OnAppConfigChange(void) &#123;  int newRotation = GetDisplayRotation();  if (newRotation != rotation_) &#123;    OnAppTermWindow();    rotation_ = newRotation;    OnAppInitWindow();  &#125;&#125;\ncamera_engine.cpp/** * 构造函数，初始camera资源 * @param app native_app_glue environment */CameraEngine::CameraEngine(android_app* app)/** * 析构造函数，释放camera资源 */CameraEngine::~CameraEngine() &#123;  cameraReady_ = false;  DeleteCamera();&#125;/** * 创建后台camera */void CameraEngine::CreateCamera(void) &#123;  // 没有权限直接返回  if (!cameraGranted_ || !app_-&gt;window) &#123;    LOGW(\"Camera Sample requires Full Camera access\");    return;  &#125;  int32_t displayRotation = GetDisplayRotation();  rotation_ = displayRotation;  // 创建NDKCamera  camera_ = new NDKCamera();  ASSERT(camera_, \"Failed to Create CameraObject\");  // 旋转角度  int32_t facing = 0, angle = 0, imageRotation = 0;  if (camera_-&gt;GetSensorOrientation(&amp;facing, &amp;angle)) &#123;    if (facing == ACAMERA_LENS_FACING_FRONT) &#123;      imageRotation = (angle + rotation_) % 360;      imageRotation = (360 - imageRotation) % 360;    &#125; else &#123;      imageRotation = (angle - rotation_ + 360) % 360;    &#125;  &#125;  LOGI(\"Phone Rotation: %d, Present Rotation Angle: %d\", rotation_,       imageRotation);  ImageFormat view&#123;0, 0, 0&#125;, capture&#123;0, 0, 0&#125;;  camera_-&gt;MatchCaptureSizeRequest(app_-&gt;window, &amp;view, &amp;capture);  ASSERT(view.width &amp;&amp; view.height, \"Could not find supportable resolution\");  // Request the necessary nativeWindow to OS  bool portraitNativeWindow =      (savedNativeWinRes_.width &lt; savedNativeWinRes_.height);  ANativeWindow_setBuffersGeometry(      app_-&gt;window, portraitNativeWindow ? view.height : view.width,      portraitNativeWindow ? view.width : view.height, WINDOW_FORMAT_RGBA_8888);  yuvReader_ = new ImageReader(&amp;view, AIMAGE_FORMAT_YUV_420_888);  yuvReader_-&gt;SetPresentRotation(imageRotation);  jpgReader_ = new ImageReader(&amp;capture, AIMAGE_FORMAT_JPEG);  jpgReader_-&gt;SetPresentRotation(imageRotation);  jpgReader_-&gt;RegisterCallback(this, [this](void* ctx, const char* str) -&gt; void &#123;    reinterpret_cast&lt;CameraEngine* &gt;(ctx)-&gt;OnPhotoTaken(str);  &#125;);  // now we could create session  camera_-&gt;CreateSession(yuvReader_-&gt;GetNativeWindow(),                         jpgReader_-&gt;GetNativeWindow(), imageRotation);&#125;// 释放cameravoid CameraEngine::DeleteCamera(void) &#123;  cameraReady_ = false;  if (camera_) &#123;    delete camera_;    camera_ = nullptr;  &#125;  if (yuvReader_) &#123;    delete yuvReader_;    yuvReader_ = nullptr;  &#125;  if (jpgReader_) &#123;    delete jpgReader_;    jpgReader_ = nullptr;  &#125;&#125;/** * 请求camera相关权限 *  通过调用CameraActivity.notifyCameraPermission, *  授权结果，调用native notifyCameraPermission() */void CameraEngine::RequestCameraPermission() &#123;  if (!app_) return;  JNIEnv* env;  ANativeActivity* activity = app_-&gt;activity;  activity-&gt;vm-&gt;GetEnv((void**)&amp;env, JNI_VERSION_1_6);  activity-&gt;vm-&gt;AttachCurrentThread(&amp;env, NULL);  jobject activityObj = env-&gt;NewGlobalRef(activity-&gt;clazz);  jclass clz = env-&gt;GetObjectClass(activityObj);  env-&gt;CallVoidMethod(activityObj,                      env-&gt;GetMethodID(clz, \"RequestCamera\", \"()V\"));  env-&gt;DeleteGlobalRef(activityObj);  activity-&gt;vm-&gt;DetachCurrentThread();&#125;/** * 调整曝光度、感光度 */void CameraEngine::OnCameraParameterChanged(int32_t code, int64_t val) &#123;  camera_-&gt;UpdateCameraRequestParameter(code, val);&#125;/** * The main function rendering a frame. In our case, it is yuv to RGBA8888 * converter */void CameraEngine::DrawFrame(void) &#123;  if (!cameraReady_ || !yuvReader_) return;  AImage* image = yuvReader_-&gt;GetNextImage();  if (!image) &#123;    return;  &#125;  ANativeWindow_acquire(app_-&gt;window);  ANativeWindow_Buffer buf;  if (ANativeWindow_lock(app_-&gt;window, &amp;buf, nullptr) &lt; 0) &#123;    yuvReader_-&gt;DeleteImage(image);    return;  &#125;  yuvReader_-&gt;DisplayImage(&amp;buf, image);  ANativeWindow_unlockAndPost(app_-&gt;window);  ANativeWindow_release(app_-&gt;window);&#125;\ncamera_ui.cpp/** * 获取旋转角度Retrieve current rotation from Java side * 调用CameraActivity.getRotationDegree */int CameraEngine::GetDisplayRotation() &#123;  ...&#125;/** * 设置曝光度、感光度 */void CameraEngine::EnableUI(void) &#123;   // 1. 获取曝光度，感光度NDKCamera::GetExposureRange\\NDKCamera::GetSensitivityRange  // 2. 调用CameraActivity.EnableUI设置&#125;/** * 拍照 */void CameraEngine::OnTakePhoto() &#123;  if (camera_) &#123;    camera_-&gt;TakePhoto();  &#125;&#125;/** * 回传照片文件路径，CameraActivity.OnPhotoTaken */void CameraEngine::OnPhotoTaken(const char* fileName) &#123;  ...&#125;/** * camera和文件写入权限回调 */void CameraEngine::OnCameraPermission(jboolean granted) &#123;  //有权限则调用OnAppInitWindow初始化&#125;/** *  native响应权限变化 */extern \"C\" JNIEXPORT void JNICALLJava_com_sample_camera_basic_CameraActivity_notifyCameraPermission(    JNIEnv *env, jclass type, jboolean permission) &#123;  //CameraEngine::OnCameraPermission权限变化&#125;/** *  native拍照 */extern \"C\" JNIEXPORT void JNICALLJava_com_sample_camera_basic_CameraActivity_TakePhoto(JNIEnv *env,                                                      jclass type) &#123;  //CameraEngine::OnTakePhoto&#125;/** *  native曝光度变化，调整预览 */extern \"C\" JNIEXPORT void JNICALLJava_com_sample_camera_basic_CameraActivity_OnExposureChanged(    JNIEnv *env, jobject instance, jlong exposurePercent) &#123;  //GetAppEngine()::OnCameraParameterChanged&#125;/** *  native感光度变化，调整预览 */extern \"C\" JNIEXPORT void JNICALLJava_com_sample_camera_basic_CameraActivity_OnSensitivityChanged(    JNIEnv *env, jobject instance, jlong sensitivity) &#123;  //GetAppEngine()::OnCameraParameterChanged&#125;\ncamera_manager.cpp   \n\n初始化camera\n更新属性\n拍照\n\nimage_reader.cpp   图片转换相关camera_listeners.cpp camera manager相关Listener\n\n项目功能为：\n\nnative监听窗口变化判断调用java请求camera相关权限\nnative创建NDKCamera，并获取曝光度、感光度属性回调到Java并展示\nnative预览\njava调用native调整预览曝光度、感光度\njava调用native拍照并回调java提示图片文件路径\n\n\nandroid-ndk-samples学习目录部份引用其他大牛的项目\n\nhello-jni by 七零八落问号演示如何从Java层调用C层代码。\n\nhello-jniCallback by 七零八落问演示如何在C层回调Java层方法。\n\nhello-libs by 七零八落问演示如何在Android Studio上使用第三方的C / C++库。\n\naudio echo by hunter800421演示如何如何使用OpenSL ES创建播放器和录音。\n\nbitmap-plasma by hunter800421演示如何使用c代码在bitmap上绘制细胞质效果。\n\n\n6.1.  camera-basic by  Tu    演示如何使用c创建camera拍照、预览。\n参考NatvieActivity事件\n","categories":["Android"],"tags":["NDK"]},{"title":"O2O收货地址管理——做一个有节操的码畜","url":"/2016/01/27/o2oAddress/","content":"前言O2O的收货地址与传统电商不同，前者自动带入地区属性，所以不需要传统B2C一样选择省市区、填写详细地址及邮编。应显示标志性位置如“新干线大厦”，不是“重庆市渝中区村55号”，也不是“重庆市渝中区两路口新干线大厦“。  \n做产品时，通常会饱受各方质疑。这个功能不应该这样，那个功能应该那样，客户说、用户说、老板说、测试说、程序说。每个人说的都不一样，每个人都有道理。产品说好，那我改，我兼容，这样的产品永远不可能获得认可。每个人的出发点，使用场景不同，当然所要的就不同。我们所需要找的是产品的使用场景、切入点，找准这两个问题其它的一切问题自然不复存在。   \n用户端中两个地方显示地址  \n  \n首页  产品类型是社区O2O\n1、显示定位地址“重庆市渝中区村55号”   问题：许多客户说，定位不准确，我都不知道这地方在哪儿。另外多个手机摆在同样的位置，显示的地址不一致。   心路历程：程序猿心里飘过1w个草泥马，各手机GPS、性能不一致，采用第三方地图。   我们开始提高定位精度，换各种SDK。甚至获取定位地址再统一采用WS获取地址。然并卵   解决办法：定位采用推荐位置“新干线大厦”\n2、显示定位地址“新干线大厦”   问题：XG5客户说，这里应该显示离当前位置最近的小区，因为我们是做社区的。   解决办法：社区不是小区。小区里面只是特定指了物业，其它的家政、维修、外卖、超市等任何产品都不只是局限在小区里面。首页展示了附近及平台推荐商家、商品，并未着重显示小区独有内容，定位为社区，不止小区。所以不予解决。  \n收货地址1、显示定位地址“重庆市渝中区村55号”与之前问题相同，但是我们可以改成与传统B2C一样由用户直接选择填写，不调用地图。问题：这样我们商家端的导航功能就不好用了。而且要由用户手动来填写太麻烦解决办法：展示附近推荐地址或搜索推荐地址，由用户选择  \n2、显示推荐地址“新干线大厦”   问题：客户说，地址不够全面（重庆市渝中区两路口新干线大厦），商家不懂路不懂送。   解决办法：社区O2O与传统B2C不同，每个商家无论超市、外卖、家政、维修等都设置了服务范围，具有区域性，所以订单中地址不需要显示地区。另外补救也可以查看导航与打客户电话沟通。 \n结语多思考，每一个步骤都是有依据有想法，然后根据实际市场需求做调整。别什么都是我改，我兼容。做一个有节操的动物。\n","categories":["Other"],"tags":["用户体验"]},{"title":"支付是同步还是异步","url":"/2018/11/21/pay-syn-or-asyn/","content":"我们一直认为支付是异步的，从未有过其它可能。最近却被收银员实力打脸。线下门店支付时，平台告诉收银员支付中，客人拿走商品后最终却支付失败，谁来买单？谁背锅？如何面对这样的声色俱厉？    \n异步支付异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送，所以在发送的信息中就要有提示接收方开始接收的信息，如开始位，同时在结束时有停止位。异步的另外一种含义是计算机多线程的异步处理。与同步处理相对，异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。以上是百度百科的概念。所以我们的支付服务一定是异步处理接收、查询支付最终结果，否则所有请求都处于等待支付状态，服务器资源不够，带宽不够，无法支撑大并发。但是我们仍然无法如此回怒收银员。所以我们要告诉她我们是“同步支付”（对，就是这么没节操）。 \n同步支付显然未支付成功顾客不能拿走商品，不管是线上还是线下。线上支付成功后，商品才会被邮寄，虚拟物品也才会发送；线下更是需要确保支付成功后才能拿走商品。\n结论支付服务程序异步，支付场景同步为什么线上线下都是同步支付却会有严重的用户体验差异呢，是因为线上支付中，不会阻断用户，用户可以干些别的事情，不需要傻等。而线下结账完，用户没办法停留下来刷刷新闻，刷朋友圈,而是需要立即离开。也就是支付程序是异步通知的，针对线下同步场景，需要由轮询或通知实现等待同步\n","categories":["Other"],"tags":["支付","异步支付","同步支付"]},{"title":"产品共享用户的疑问","url":"/2018/09/20/product-think-facepay-user/","content":"最初接手”刷脸支付“项目时就有一个疑问，为什么这个项目的用户体系与公司已有的用户体系是隔离的？\n共有用户体系好处\n有庞大用户基数\n宣传导流用户转换更容易\n降低新产品推广难度\n\n  \n与公司用户体系共同点1.以用户手机号作为账号2.实名认证\n与公司产品不同点\n旧有用户绑定银行卡（代扣）或公司已有额度产品；刷脸支付目前有微信免密支付\n刷脸支付有绑定用户脸部特征，公司已有用户也有做实名认证或活体识别，只是可能未转换特征信息\n\n其他微信、支付宝等都在做人脸支付，已有用户基数和用户习惯上可能不及他们。但是还有许多其它可做的，我们只需要把每一个问题做到极致。\n","categories":["Other"],"tags":["人脸支付","引流"]},{"title":"如何主动PUSH SDK更新给开发者","url":"/2017/12/01/push-update-info-2-stargazers-by-github/","content":"之前苹果禁用jspatch时，涉及到的SDK全部需要更新。此时开发者得全面排查所使用SDK是否需要更新。怎么查？一个一个去SDK官网查看是否有更新解决方案。啰嗦，实现上就是想维护Github上面可怜的Star，所以想利用Github的开放api更新了SDK给他们发个邮件  \n1、查询Star的api文档：https://developer.github.com/v3/activity/starring/调用：https://api.github.com/repos/2tu/fit/stargazers发现只有user，没有其邮箱  \n2、查询用户信息文档：https://developer.github.com/v3/users/调用：https://api.github.com/users/2tu发现并没有想要的email，提示如下：Note: The returned email is the user’s publicly visible email address (or null if the user has not specified a public email address in their profile). The publicly visible email address only displays for authenticated API users.只能显示用户自己的email，虽然可以通过爬虫直接爬取，但是不正当，该想法搁置\n","categories":["Other"],"tags":["如何主动PUSH","SDK更新给开发者","SDK","主动push","github api","fit"]},{"title":"MySQL中的float、double的精度是如何丢失的？","url":"/2024/05/14/problems-with-float-in-mysql/","content":"前言朋友在设计表的时候很疑惑小数的时候到底该用Float、Double还是Decimal，什么情况下使用？我们总听说Float、Double会丢失精度，如果是金钱则使用Decimal。但是在业务场景里面，我们期望的是程序是可靠的，所有数据都是准确的。那是不是意味着所有的字段都要用Decimal,那Float、Double还有什么用？所以我们需要理解到精度到底是怎么丢失的，什么情况下丢失，什么情况下不丢失？才能得出Float、Double在怎样情况下是可靠的，才能在需要使用的时候判断出该使用什么数据类型。\nFloat为什么会丢失？Float、Double存储的是近似值。为什么是近似值，先看看各数据类型空间占用情况\n\n\n\n类型名称\n说明\n存储需求\n\n\n\n\nFloat\n单精度浮点数\n4字节\n\n\nDouble\n双精度浮点数\n8字节\n\n\nDecimal\n压缩的“严格”定点数\nDecimal(M,D)，如果M&gt;D，为M+2否则为D+2字节\n\n\n\n存储Float、Double时采用将数据转换为二进制进行存储。存储格式为\n比如8.25用二进制表示可表示为1000.01，转成指数的形式1.00001*2^3,在计算机中\n这其中小数的二进制计算方式与整数不同，需要使用小数部分2取整数，直到为0例如0.32的二进制计算方式如下0.322 = 0.64 00.642 = 1.28 10.282 = 0.56 00.562 = 1.12 10.122 = 0.24 00.242 = 0.48 00.482 = 0.96 00.962 = 1.92 10.922 = 1.84 10.842 = 1.68 10.682 = 1.36 10.36*2 = 0.72 0…\n对于这样整除不尽或者超过32位的情况，就一定会丢失精度，或者四舍五入后得到的近似值针对float情况，至少我们可以得出结论：1.如果一个float型数据转成二进制后的第32位之后都是0，那么数据是准的2.如果一个float型数据转成二进制后的第32位之后不全为0，则数据就会存在误差\n重新说明float(M, D)两个参数的意义这两个参数表示一共能存M位，其中小数点后占D位。比如float(3,1)表示一共3位，其中小数点后1位数字。这里会有两个误区\n数据的精度总是能精确到D位，也就是数据的不精确一定出现在小数点后数据存储的时候只能存储到D位小数\n\n第一个误区，如果对于float4字节的存储空间连整数的存储不下的时候，连整数都有误差的，更何况小数，所以存储空间大小决定存储精度，和D值无关。来看这样一个例子\nmysql&gt; create table f2 (f1 float(15,2));Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into f2 values (123456789.39);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from f2;+--------------+| f1           |+--------------+| 123456792.00 |+--------------+1 row in set (0.00 sec)\n最后你会发现，连整数都不准了，小数被完全抹去了。\n\n第二个误区，对于存储而言，是和D无关的一个参数。因为浮点型数据最终都要被转成二进制进行存储。并且对于float，这个二进制只能有32位0和1的组合。看下面的例子：\nmysql&gt; select * from f;+-----------+| f1        |+-----------+| 131072.31 |+-----------+1 row in set (0.00 sec)mysql&gt; alter table f modify f1 float(10,4);Query OK, 0 rows affected (0.02 sec)Records: 0  Duplicates: 0  Warnings: 0mysql&gt; select * from f;+-------------+| f1          |+-------------+| 131072.3125 |+-------------+1 row in set (0.00 sec)\n可以看到，修改一下显示宽度D，这个时候可以看到MySQL真正存储的数字是131072.3125\n\n\n怎么样才能存储一个准确的数据如果采用float或者double类型的话，数据有时候完全准确的，有时候是不准确的，怎么才能存储一个准确的数字，完全看你需要存什么样的数据，假如存储一个8.25这样的数字，那永远都是准确的。但是如果存储0.9这样的数字，则永远存不准确。\n所以如果一个实数在MySQL中存储准确的话，会出现以下三种情况\n\n数据真的准确，数据能在有限的存储空间里完全存储起来\n数据存储被截断，但是通过四舍五入依然能够将数据显示准确\n数据存储被截断，通过四舍五入不能将数字正确显示\n\n关于decimal类型通过前面的分析，了解了float和double类型的区别和误差来源。但是decimal类型是MySQL官方唯一指定能精确存储的类型，也是DBA强烈推荐和金钱相关的类型都要存储为decimal类型，如果猜想decimal类型的存储格式的话，那么一下两种可以保持数据的准确性\n\n继续扩大存储空间，比double更大一个级别，比如128位甚至更多\n通过字符串化或者其他的方式特殊存储起来\n\n这两种方式都能实现decimal精确存储，但是由于MySQL指定decimal类型最大长度为65.在我们能测试的范围内，decimal并没有出现误差。\n如何选择float，double，decimal结论总是放在最后，根据上面的分析：可以得出以下结论\n\n如果你要表示的浮点型数据转成二进制之后能被32位float存储，或者可以容忍截断，则使用float，这个范围大概为要精确保存6位数字左右的浮点型数据 比如10分制的店铺积分可以用float存储，小商品零售价格(1000块之内)\n\n如果你要表示的浮点型数据转成二进制之后能被64位double存储，或者可以容忍截断，这个范围大致要精确到保存13位数字左右的浮点型数据 比如汽车价格,几千万的工程造价\n\n相比double，已经满足我们大部分浮点型数据的存储精度要求，如果还要精益求精，则使用decimal定点型存储 比如一些科学数据，精度要求很高的金钱\n\n\n写在最后理论上的东西永远比不上实践，应用场景大于一切理论。选择float或者double或者decimal有时候也要看场景，比如我们可以用double存储一个小商铺的季度营业额（几千万），单独用double存储的时候没有问题，当多个季度，多个年份算总3年内的营业额是，就会出现问题，再也算不出一个准确的答案。所以，如果考虑情况没那么有把握的情况下，推荐使用decimal，最后，也可以通过其他手段避开这些问题，比如存储商品价格可以使用 乘以100的形式存储，展示价格的时候再除以100\nB.3.4.8 Problems with Floating-Point Values谈谈MySQL如何选择float, double, decimal\n","categories":["Data"],"tags":["MySQL"]},{"title":"自定义ShardingSphere的JSON加解密器","url":"/2024/05/28/shardingsphere-encrypt-json/","content":"基于数据安全的目的，需要对敏感数据进行加密存储。其中有整个字段是敏感内容的数据，也有部分灵活内容存储为JSON，JSON中的部分path为敏感内容。针对这部分内容，需要对JSON指定path加解密，以避免对整个JSON加解密造成存储空间、应用缓存资源浪费。\nShardingSphere整体架构\n加密规则加密配置主要分为四部分：数据源配置，加密算法配置，加密表配置以及查询属性配置，其详情如下图所示：JSON加解密器实现在加密配置-&gt;用户自定义处\n配置加密器类型配置spring:  shardingsphere:    rules:      encrypt:      \tencryptors:          json_encryptor:            type: json\n加密字段配置spring:  shardingsphere:    rules:      encrypt:      \ttables:          t_user:            columns:              info:                plainColumn: info                cipherColumn: info_cipher                encryptorName: json_encryptor\nJSON path加密配置spring:  shardingsphere:    rules:      encrypt:      \tencryptors:          json_encryptor:            props:              column0_path: bankCard &lt;!-- &#123;唯一名字&#125;_path=需要加密的json路径   --&gt;              column0_path_encryptor: bankCard &lt;!-- &#123;唯一名字&#125;_path_encryptor=加密类型 --&gt;\n自定义加密接下来就是自定义ShardingSphere加密部分可以查看ShardingSphere官网，EncryptAlgorithm继承EncryptAlgorithm\n\n重写getType为json（加密器类型配置处使用）\n重写setProps（JSON path加密配置会从此处拿到）\n重写encrypt、decrypt，在遇到加密字段配置中的SQL时，触发改写SQL，可以根据props中配置的json path自定义加密。\n\n实现SPI在代码的resources路径下创建META-INF\\services\\org.apache.shardingsphere.spi.encrypt.ShardingEncryptor文件内容为自定义加密类的全路径，如：com.company.shardingsphere.encrypt.JSONEncryptor\n","categories":["Data"],"tags":["ShardingSphere"]},{"title":"Spring中Bean的作用域与StepScope关系、疑问","url":"/2018/01/12/spring-bean-scope/","content":"Spring Bean有5个作用域，但是最近有需求在多个地方获取同一个Bean，只修改其中一个参数。那么Bean只在一个地方注入，修改属性就好，名字能一样吗？一系列问题这个StepScope是什么鬼，5个默认的Scope能满足需求吗？ \nBean scopes\n\n\nScope\nDescription\n\n\n\n\nsingleton\nScopes a single bean definition to a single object instance per Spring IoC container.\n\n\nprototype\nScopes a single bean definition to any number of object instances.\n\n\nrequest\nScopes a single bean definition to the lifecycle of a single HTTP request; that is each and every HTTP request will have its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\nsession\nScopes a single bean definition to the lifecycle of a HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\nglobal session\nScopes a single bean definition to the lifecycle of a global HTTP Session. Typically only valid when used in a portlet context. Only valid in the context of a web-aware Spring ApplicationContext.\n\n\n\n通常我们使用的是singleton，默认也是。在测试中发现提供相同类型的Bean，需要指定不同的name标识（@Bean(“three”)），使用时对应@Qualifier(“three”)。  \n疑问：经测试发现提供相同类型Bean，不指定Qualifier会出错，但是在SpringBatch中指定了@StepScope却没报错，那是如何来区分应该在哪个Step中有效的呢？通过查看StepScope文档可以发现应该还有自定义Scope的存在来实现个性化需求，见Bean scopes之4.4.5 Custom scopes。\n参考Spring中Bean的作用域、生命周期Spring中Bean的五个作用域\n","categories":["Java"],"tags":["Spring","SpringBatch","Bean","scope","Qualifier","StepScope"]},{"title":"选择横表还是纵表","url":"/2023/06/01/row-or-column-table/","content":"数据库：MySQL 5.7业务上有25个维度共2000多个指标数据需要存储。对于这种可变字段的指标数据，第一想法是采用纵表存储。但是具体该如何选择还是得结合业务看优缺点才行。\n业务场景数据量1k台设备，每台设备每5分钟一次全量指标数据，存储60天\n\n纵表：602460/510002000=345.6亿\n横表：345.6亿/2000=1728万\n\n查询场景\n按指标维度+时间范围分页查\n按同一时间上报的指标数据（时间+指标名称）\n\n方案纵表从数据量来看纵表数据量非常大，需考虑分表来解决查询效率问题。如果简单按查询数据量每表2kw来算(数据量不能简单按2kw算，需要计算字段长度，索引的页数大小)，纵表需要分17280张表。按时间分页查询时，需要全表联合查询。\n\n按设备分数据量：1k张表，每张3456万7天分页查询：1k张表联合查询缺点：数据量大；数据分布不均匀；分页查询慢\n\n按维度分数据量：25张表，138240万=13.824亿缺点：数据量大\n\n按维度+时间分数据量：1500张表，2.304亿7天分页查询：7张表关联查询缺点：表数量太多；数据分布不均匀；\n\n\n横表\n不分表缺点：字段列数多，MySQL是否支持呢？下面会列一下\n\n按维度分数据量：25张表，每张表约80个字段，70万条数据7天分页查询：不需要联表查询缺点：数据分布不均匀；表字段多；\n\n按维度+细分维度分细分指标只在计算时使用（同一时间上报的指标数据），分页查询时不使用数据量：40张表，每张表约50个字段，44万条数据7天分页查询：不需要联表查询缺点：数据分布不均匀；字段相对减少；\n\n\nMySQL规范每张表支持最大列数Column Count Limits：1017\n每行字节数Row Size Limits：65,535 bytes\n\n","categories":["Data"],"tags":["MySQL","横表","纵表"]},{"title":"统计学第一篇，均值、中位数、众数","url":"/2018/02/05/statistics-learn1-average/","content":"均值、中位数、众数是表示一组数据集中趋势的量数，下面以“1,2,3,3,5,7,7,8,9,10”数据集为例\n均值,中位数,众数  \n\n\n\nType\n示例\n值\n说明\n\n\n\n\n均值(Mean)\n(1+2+3+3+5+7+7+8+9+10)/10\n5.5\n算术平均数。求和，再除个数\n\n\n中位数(Median)\n(5+7)/2\n6\n选取平均数。从小到大排序;选取中间的数求算术平均数\n\n\n众数(Mode)\n3,7\n3,7\n数据集中出现次数最多的数\n\n\n\n众数，有多个数出现的次数最多，则它们都是众数使用Java、Excel数据分析如何有效投资房产中在自己实际投资分析中，应该将房价清洗为以千或500为单位后用众数及中位数进行分析更为合理，否则异常值会误导分析\n","categories":["Data"],"tags":["均值","中位数","众数"]},{"title":"C++模板多类型形参","url":"/2019/01/23/template-multiple-typename/","content":"C++模板与Java泛型有共通之处，为了参数化代码。所以也疑惑C++中的类模板是否与Java泛型相同只能指定一个类型？C++模板格式1、 函数模板格式template&lt;typename T1, typename T2, ...&gt; 返回类型 函数名(参数列表)&#123;    ...&#125;2、类模板格式template&lt;typename T1, typename T2, ...&gt; class 类名&#123;    ...&#125;;\n\n由此可见，无论函数模板、类模板都支持多类型。如：template&lt;typename T1,typename T2&gt; class MultipleTypename&#123;    private:        T1 a;        T2 b;    public:        void setA(T1 a);        void setB(T2 b);        T1 getA();        T2 getB();&#125;;\n","categories":["C/C++"],"tags":["模板","多形参"]},{"title":"统计学第二篇，极差、中程数","url":"/2018/02/09/statistics-learn2-range-mid-range/","content":"概念极差，数据分开有多远，值越大分开越远，越小数据越紧密中程数，考虑集中趋势的又一种方式仍然以“1,2,3,3,5,7,7,8,9,10”数据集为例\n极差,中程数  \n\n\n\nType\n示例\n值\n说明\n\n\n\n\n极差(range)\n10-1\n9\n最大减去最小\n\n\n中程数(midrange)\n(10-1)/2\n4.5\n最大减最小，再求算术平均数\n\n\n\n","categories":["Data"],"tags":["极差","中程数"]},{"title":"Java类文件在JVM运行的生命周期","url":"/2024/02/27/the-class-file-lifecycle-of-jvm/","content":"java Class文件结构Java .class 文件是 Java 编程语言的关键组件，遵循精确且定义的结构。 这种结构不仅对于 Java 虚拟机 (JVM) 正确加载和执行字节码至关重要，而且还提供了有关编译后的 Java 代码的大量信息。 下面，我们深入研究类文件结构的基本元素，详细说明每个组件及其在整体架构中的重要性。\nclass文件格式类文件由单个 ClassFile 结构组成。 该结构由 JVM 规范定义并遵循特定格式，其中包括以下主要部分：\n\nMagic Number魔数：固定值 (0xCAFEBABE)。 此唯一标识符验证该文件是否是 JVM 可读的有效类文件。\nVersion Information版本号：major_version、minor_version，java版本号\nConstant Pool常量池\nAccess Flags访问标识\nThis Class, Super Class,and Interfaces类索引、父类索引与接口索引集合\nFields字段集合\nMethods方法表集合\nAttributes属性表集合\n\n以上信息如何查看？javap [options] classes...\nJVM需要使用上述信息来正确加载、验证和执行\n其是常量池，它是一个集中的字典，经常被类文件中的其他部分引用，突出了它在整个架构中的重要性。\nClass文件在JVM中的生命周期\n1. Loading加载类加载过程执行以下三个功能：从clas文件创建二进制数据流根据内部数据结构解析二进制数据创建 java.lang.Class 的实例完成此操作后，类实例就可以进行链接了。\n2. Linking链接2.1 Verification验证此步骤可确保安全性和完整性。JVM验证class文件的正确性，文件格式验证、语法是否有效、是否符合Java语言规范。\n2.2 Preparation准备在准备过程中，JVM 会为类静态变量分配内存，并将其初始化为默认值。\n2.3 Resolution解析解析阶段包括将类文件中的符号引用解析为直接引用。这就是 JVM 常量池发挥关键作用的地方。主要针对类或接口、字段、类方法、方法类型等。\n3. Initializes初始化执行静态块： 这一阶段涉及执行静态初始化程序和静态块。JVM 会初始化静态字段，并按照它们在类文件中出现的顺序执行任何静态初始化块。设置最终值： 为类的最终变量分配值，这些值在类的生命周期内不可更改。\n4. Usage使用实例化： JVM 根据应用程序的需要创建类的实例。执行： 根据运行程序的要求调用和执行方法，访问字段。JVM 会将字节码解释或即时编译为机器代码以便执行。\n5. Unloading卸载垃圾回收： 当一个类不再需要，也没有对其实例的实时引用时，它就可以被卸载。JVM 的垃圾回收器会回收分配给类的内存。\nThe Anatomy of a Java Virtual Machine Class FileThe Execution Lifecycle of a Java ApplicationjavapChapter 4. The class File Format\n","categories":["Java"],"tags":["Interview","JVM"]},{"title":"符合国际标准的城市编码","url":"/2023/08/03/the-international-standard-country-codes/","content":"问题fork的项目running_page有一个Issue提到国家和地区识别不正确，看了数据样例较为复杂，有的是有国家省市区，有的只有部分，还有国外的。running_page中代码以逗号分隔取国家，然后根据统计用区划代码和城乡划分代码对比取出城市。\n问题是，数据是全球的用户是全球的，那全球各个国家和区域的标准应该是什么？中国有省市区，那其他国家有吗？有统一标准吗？\n国际标准 ISO 3166全球化那就必然要找国际标准了，看这里ISO 3166, Codes for the representation of names of countries and their subdivisions\n里面又包含了\n\nISO 3166-1 国家代码\nISO 3166-2 国家分支机构代码\nISO 3166-3 国家曾用名代码\n\n如何使用我们拿到gps后做需要逆地址解析拿到ISO 3166标准的代码，有哪些方式可以呢，google map？\n我调研了2个方式\n\nGeoNamesThe GeoNames geographical database covers all countries and contains over eleven million placenames that are available for download free of charge.\n免费全球地理数据库\n注册账号，每个账号有免费调用接口额度，对于个人来说完全够了，接口不同占用额度不同，具体如下\nTerms and Conditions\n\nGeoNames Webservice Credits\n\nNominatimNominatim\nNominatim 是一个开源的地理数据库，可通过 REST API 访问。它由 OpenStreetMap 社区维护，包含来自各种来源的数据，包括 OpenStreetMap 数据库、维基百科和其他开放数据集。\nNominatim 解析的地址是使用国际标准化组织 (ISO) 3166 标准。ISO 3166 标准定义了世界各国的名称和代码。Nominatim 还使用其他标准，如 ISO 6709 标准，该标准定义了地理坐标的格式。\n有python库Nominatim\n参考对ISO3166《国家和所属地区名称代码》国际标准的几点认识\n","categories":["Other"]},{"title":"TV Apps Checklist","url":"/2016/02/29/tvApplication/","content":"最近开发一款定制运行于Letv的 TV应用（流云TV），主要用于数据报表展示及小部份交互。本文主要参考于电视猫、VST两款应用，适配小米电视及乐视。\nSDK版本及分辨率国内目前的电视都是从4.x的Phone SDK修改，所以我们的适配如下表\n\n\n\n应用\nminSdkVersion\ntargetVersion\n分辨率\n\n\n\n\n电视猫\n8\n16\n1280*720\n\n\nVST\n15\n19\n1920*1080\n\n\n流云TV\n14\n19\n1920*1080(xxhdpi)\n\n\n\n  \n焦点状态显示电视端因为缺少触摸操作，焦点处理尤为重要。normal、focus、press状态设计上要明显。  \n其它剩下的就是按键处理、内容显示设计及是否显示屏保等。Manifest&lt;uses-feature\n        android:name=&quot;android.software.leanback&quot; android:required=&quot;true&quot; /&gt;&lt;uses-feature\n        android:name=&quot;android.hardware.type.television&quot;\n        android:required=&quot;true&quot; /&gt;\n&lt;category android:name=&quot;android.intent.category.LEANBACK_LAUNCHER&quot; /&gt;  \n参考：小米应用开发者文档乐视遥控器按键对应表Building Apps for TV\n","categories":["Android"],"tags":["Android TV"]},{"title":"use RestTemplate in Spring","url":"/2017/03/13/use-RestTemplate-in-Spring/","content":"Spring中提供RestTemplate方便访问Web服务，不再需要使用HttpClient、HttpComponents等\n差异使用方式详细见api，唯一注意区别参数uriVariables，遵循RESTful风格为uri变量，如：https://api.github.com/users/2tu可以写成\nrestTemplate.getForObject(\"https://api.github.com/users/{userName}\", String.class, \"2tu\");  \nMap&lt;String, String&gt; uriVariables = Collections.singletonMap(\"userName\", \"2tu\"); \nrestTemplate.getForObject(\"https://api.github.com/users/{userName}\", String.class, uriVariables);\n\n注：SpringBoot默认采用jackson\n\n参考：Consuming a RESTful Web ServiceRestTemplate API\n","categories":["Java"],"tags":["Spring","RestTemplate","HttpClient"]},{"title":"蓝牙和WIFI在智能硬件中的应用","url":"/2019/04/30/u-know-bluetooth-and-wireless/","content":"某天加班后在一个苍蝇馆子吃完饭开发票。老板娘用手机将公司信息录入后一个黑暗的角落里付出了吱吱..吱吱吱的打印声，整个店里面没有电脑。好奇解决小店摆不下电脑，不会使用电脑，不愿多花钱买电脑的黑科技如何实现手机连接打印机打印发票。\n手机无线传输有三种，蓝牙、WIFI，还有NFC。这种场景下可以排除NFC。  \n在我古老认知中，蓝牙可以传照片、文件，还有蓝牙耳机。\nWIFI可以上网，还有在换手机时备份数据也是用WIFI。  \n\n这个打印发票是采用的哪一种呢？\n一定不能是WIFI，从用户使用角度来看，手机连打印机的WIFI后，手机无法上网。打印机连接手机，打印机无法辨识连接哪个WIFI。\n从硬件上来看，WIFI较蓝牙虽然传输距离长，但功耗高，价格更贵。\n所以这款打印机与手机是采用的蓝牙传输。\n\n其实智能设备交互已经侵入我们生活，无线数据传输都逃不出这三种模式。\n蓝牙：音响、耳机、手环、手机刷卡器\nWIFI：扫地机器人、小米行车记录仪、摄像头、空调、洗衣机、窗帘，好多好多  \nNFC：公交充值、门卡等\n蓝牙都是直连（两个设备连接），而WIFI部份在不需要介入外网的情况下可以直连，另外还可以接入外网方便远程查看和操作。\n智能硬件就这么简单，所以你有想好如何利用他们解决痛点吗？\n未来已来，你来不来？\n—  END  —分享程序员所看、所想、所悟、所望\n","categories":["Other"],"tags":["智能硬件","WIFI","蓝牙"]},{"title":"VUE中使用Mock模拟数据请求","url":"/2020/04/08/use_mockjs_vue/","content":"是Mock.js 是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试。提供了以下模拟功能：\n\n根据数据模板生成模拟数据\n模拟 Ajax 请求，生成并返回模拟数据\n基于 HTML 模板生成模拟数据\n\n记录一下在项目中的使用方法\n安装npm install mockjs\n当然通常在项目中会在package.json中添加mockjs依赖，再npm install所有项目中需要依赖的库\n\"dependencies\": &#123;    \"mockjs\": \"^1.1.0\"  &#125;\n引用src/mock/index.js//引入mockimport Mock from 'mockjs'let configArray = []// 使用webpack的require.context()遍历所有mock文件const files = require.context('.', true, /\\.js$/)files.keys().forEach((key) =&gt; &#123;  if (key === './index.js') return  configArray = configArray.concat(files(key).default)&#125;)// 设置拦截ajax请求的相应时间Mock.setup(&#123;  timeout: '200-600'&#125;);// 注册所有的mock服务configArray.forEach((item) =&gt; &#123;  for (const [path, target] of Object.entries(item)) &#123;    const protocol = path.split('|')    Mock.mock(protocol[1], protocol[0], target)  &#125;&#125;)\nmain.js中引入\n//开发环境引入if (process.env.NODE_ENV === 'development') &#123;  require('@/mock')&#125;\nmock文件下建立personList.jslet personList = [&#123;        id: 1,        name: '小丽',        age: '18',        number: '8'    &#125;,&#123;        id: 1,        name: '小芳',        age: '20',        number: '6'    &#125;]export default &#123;    'get|/parameter/query':  option =&gt; &#123;    return &#123;      status: 200,      message: 'success',      data: personList    &#125;;  &#125;&#125;\n接下来在网络请求时，发现如果是get请求路径是/parameter/query，就会返回我们mock定义好的数据。另外还有其它语法来生成随机数据。详细参考数据模板定义 DTD\n参考 Mock.js Mock\n","categories":["Web"],"tags":["Mock","mockjs","vue"]},{"title":"Manifest中找不到versionCode?","url":"/2018/01/09/versionCode-not-exist-in-manifest/","content":"起因17年做的update（升级平台）交由其它团队维护后，发现解析Manifest后未找到versionCode、versionName信息。大家都讲终极绝招，使用aapt来获取，但是这样耦合低，并且得在服务器上维护Android环境，显然不合理。所以要干他此文都是解决思路，心急直接看最后的结论\n环境\nAndroid Studio 3.0\nGradle 4.1\ntargetSdkVersion 26 minSdkVersion 8\napktool 2.3.1\nAXMLPrinter2\nAPKParser\n\n\n分析问题apktool第一想法，通过apktool反编译查看AndroidManifest中是否不存在version信息。  \n&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.tu.sample\" platformBuildVersionCode=\"26\" platformBuildVersionName=\"7.1.1\"&gt;\n结果是不存在的，于是把怀疑指向是否google的锅，Android Studio?Gradle?targetVersion?\nAndroid Studio?Android Studio 3.0 Canary 2: attribute ‘android:versionCode’ not found然后经过对比发现仍然不是这个问题，继续搞  \nGradle?targetVersion?安装在低版本的手机上仍然可以获取，即使Google要改这个规则至少得兼容旧版本。并且阅读Android官方文档后也没见有提及，所以这个原因也可以排除。见设置应用版本信息程序猿要开始怀疑人生了\nAndroid Studio Analyze APK无意间使用Analyze APK查看了一下，信息如下\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest    xmlns:android=\"http://schemas.android.com/apk/res/android\"    package=\"com.tu.sample\"    platformBuildVersionCode=\"26\"    platformBuildVersionName=\"7.1.1\"    android:versionCode=\"24400\"    android:versionName=\"2.4.4\"&gt;``` 艹尼玛，居然是有的，因为官方解析，还是因为真的有？#####  Build目录  查看build/intermediates/manifests/full/debug和release下的AndroidManifest均与Analyze APK查看的内容匹配。  开始怀疑自己#####  apktool?再看apktool解析出来的内容，其中有一个文件apktool.yml，简要内容如下\n!!brut.androlib.meta.MetaInfoapkFileName: sample.apkcompressionType: falsedoNotCompress:\n\narscisFrameworkApk: falsepackageInfo:forcedPackageId: ‘127’renameManifestPackage: nullsdkInfo:minSdkVersion: ‘8’targetSdkVersion: ‘26’usesFramework:ids:\n1tag: nullversion: 3.0.1versionInfo:versionCode: ‘24400’versionName: 2.4.4`居然也是有的，那么是解析方式变了，还是Manifest中没有？终极绝招读源码，但是由于我只是抽空（好奇）支持一把，没有时间耗（懒）。但总是舒了一口气，不用再使用aapt这种方式来解决了。回到我们自己的解析程序中来\n\n\n\nAXMLPrinter2update中采用AXMLPrinter2库来解析。这个库早已没维护并衍生了很多其它版本，如APKParser发现通过这个库解析出来的Manifest是含有version信息的，内容与Analyze APK一致。\n结论Manifest中仍然有版本信息，规则不变。由于AXMLPrinter2解析库问题导致。具体原因不分析，留给目前的团队和有兴趣的人解决。\n参考设置应用版本信息AXMLPrinter2APKParserAndroid Studio 3.0 Canary 2: attribute ‘android:versionCode’ not found\n","categories":["Android"],"tags":["versionCode","manifest","APKParser","AXMLPrinter2"]},{"title":"Android中添加背景水印，含WebView","url":"/2020/04/19/watermark-by-android/","content":"绝密资料，必须加上水印背景以免外传，在Android中如何实现呢？分为普通背景水印和加载网页中添加水印。当然网页本身可以直接加，WebView加载下来直接就有了，这种方案我们不讨论，只讨论在WebView中追加。先上效果图：普通背景水印网页水印\n普通背景水印创建一个水印Bitmap，为rootView设置背景。so easy,直接上代码 \n@Overrideprotected void onCreate(Bundle savedInstanceState) &#123;  super.onCreate(savedInstanceState);  setContentView(R.layout.activity_watermark);  if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.JELLY_BEAN) &#123;    findViewById(android.R.id.content).setBackground(background(\"水印\"));  &#125;else&#123;    findViewById(android.R.id.content).setBackgroundDrawable(background(\"水印\"));  &#125;&#125;BitmapDrawable background(String watermark)&#123;  Bitmap bitmap = Bitmap.createBitmap(240, 240, Bitmap.Config.ARGB_8888);  Canvas canvas = new Canvas(bitmap);  canvas.drawColor(Color.WHITE);  Paint paint = new Paint();  paint.setColor(Color.GRAY);  paint.setAlpha(80);  paint.setAntiAlias(true);  paint.setTextAlign(Paint.Align.LEFT);  paint.setTextSize(40);  Path path = new Path();  path.moveTo(30, 150);  path.lineTo(300, 0);  canvas.drawTextOnPath(watermark, path, 0, 30, paint);  BitmapDrawable bitmapDrawable = new BitmapDrawable(bitmap);  bitmapDrawable.setTileModeXY(Shader.TileMode.REPEAT, Shader.TileMode.REPEAT);  bitmapDrawable.setDither(true);  return  bitmapDrawable;&#125;\n网页水印网页背景水印在网页加载完成后插入javascript添加div水印String addWaterMarker(String watermark) &#123;    String js = \"var newscript = document.createElement(\\\"script\\\");\";    js += \"var bbTextNode = document.createTextNode(\\\"\";    js += \"var can = document.createElement('canvas');\";    js +=        \"var body = document.body;body.appendChild(can);can.width=400; can.height=200;can.style.display='none';\"            + \"var cans = can.getContext('2d');cans.rotate(-20*Math.PI/180);cans.font = '16px Microsoft JhengHei';\"            + \"cans.fillStyle = 'rgba(17, 17, 17, 0.50)';cans.textAlign = 'left';\"            + \"cans.textBaseline = 'Middle';cans.fillText('watermark',can.width/3,can.height/2);\"            + \"body.style.backgroundImage='url('+can.toDataURL('image/png')+')';\"    ;    js += \"\\\");\";    js += \"newscript.appendChild(bbTextNode);\";    js += \"var t = document.createTextNode(\\\"alert('action');\\\");\";    js += \"newscript.appendChild(t);\";    //js += \"newscript.onload=function()&#123;xxx();&#125;;\";  //xxx()代表js中某方法    js += \"document.body.appendChild(newscript);\";    return js;  &#125;  String addWaterMarkerDiv(String watermark) &#123;    String js = \"var newscript = document.createElement(\\\"script\\\");\";    js += \"var waterMarkDiv = document.createTextNode(\\\"\"        //+\"if(document.getElementById('waterMark') != null) return;\"        + \"var m = 'waterMark';\"        + \"var newMark = document.createElement('div');\"        + \"newMark.id = m;\"        + \"newMark.style.position = 'absolute';\"        + \"newMark.style.zIndex = '9527';\"        + \"newMark.style.top = '0px';\"        + \"newMark.style.left = '0px';\"        + \"newMark.style.width = '800px';\"        + \"newMark.style.height = '400px';\"        + \"alert('newmark');\"        + \"\\\");\"    ;    js += \"newscript.appendChild(waterMarkDiv);\";    js += \"var bbTextNode = document.createTextNode(\\\"\";    js += \"var can = document.createElement('canvas');\";    js +=        \"var body = document.body;body.appendChild(can);can.width=400; can.height=200;can.style.display='none';\"            + \"var cans = can.getContext('2d');cans.rotate(-20*Math.PI/180);cans.font = '16px Microsoft JhengHei';\"            + \"cans.fillStyle = 'rgba(17, 17, 17, 0.50)';cans.textAlign = 'left';\"            + \"cans.textBaseline = 'Middle';cans.fillText('watermark',can.width/3,can.height/2);\"            + \"newMark.style.backgroundImage='url('+can.toDataURL('image/png')+')';\"            + \"newMark.style.filter = 'alpha(opacity=50)';\"            + \"document.body.appendChild(newMark);\"    ;    js += \"\\\");\";    js += \"newscript.appendChild(bbTextNode);\";    js += \"document.body.appendChild(newscript);\";    return js;  &#125;\n完整demo例子\n引用【Android】webview javascript 注入方法Javascript 网页水印(非图片水印)实现代码html如何添加水印？ \n","categories":["Android"],"tags":["水印"]},{"title":"使用AndroidStudio开发JNI并开启Native Debugger","url":"/2016/03/24/welcomeJNI/","content":"不使用eclipse开发JNI，使用谷歌亲儿子AndroidStudio，并开启Native Debugger  \n一、创建JNI工程1、android.useDeprecatedNdk=true在gradle.properties中添加“android.useDeprecatedNdk=true”，否则会报”Error: NDK integration is deprecated in the current plugin.  Consider trying the new experimental plugin.“  \n2、创建CLog类添加native方法public static native void i();  \n3、采用javah使用生成头文件创建JNI目录\n\n创建后实际的jni目录为app/src/main/jni，与java同级打开Terminal,执行javah -d ../jni/ -jni com.tu.jnilog.clog.CLog命令生成头文件至jni目录  \n4、实现头文件\"com_tu_jnilog_clog_CLog.h\"  #include &lt;android&#x2F;log.h&gt;  #define LOG_TAG &quot;CLOG&quot;  #define LOGI(...)    __android_log_print(ANDROID_LOG_INFO, LOG_TAG,  __VA_ARGS__)void Java_com_tu_jnilog_clog_CLog_i        (JNIEnv *env, jclass)&#123;        LOGI(&quot;c++ call android log api&quot;);&#125;\n5、添加moduleName及支持平台接下来将c编译成so，引用并调用。在AndroidStudio中在defaultConfig配置中添加moduleName &quot;CLog&quot;  ldLibs &quot;log&quot;&#x2F;&#x2F;实现__android_log_print  abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot;&#x2F;&#x2F;如果不添加，测试发现是全部平台  &#125;\n6、loadLibrary在CLog类中添加\tSystem.loadLibrary(&quot;CLog&quot;);&#x2F;&#x2F;与指定的module&#125;\n二、开启Native Debugger1、激活Native代码调试在module下build.gradle中buildTypes添加\n  jniDebuggable true\n}\n\n否则会报Error: Build type isn’s JNI debuggable\n2、Edit Configurations Run-&gt;Edit Configurations-&gt;开启Hybrid调试 \n打上断点，选择创建的Native运行即可\n示例工程参见 JNILog\n参考：Android Studio 1.5+ 中混合调试\n","categories":["Android"],"tags":["JNI","AndroidStudio","Debugger","Native","C++"]},{"title":"服务器时间错误导致MySQL证书错误问题","url":"/2023/06/24/what-cause-hibernate-dialect-not-set/","content":"HibernateException ‘hibernate.dialect’ not set同一个jar包，在某个环境下启动应用报错，另一个环境可以正常启动。报上面的错误caused by: org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when 'hibernate.dialect' not set\nMySQL证书错误查看MySQL日志mysql/mysqld.log其中有2000-02-05T02:19:10.762462Z 0 [Note] Found ca.pem, server-cert.pem and server-key.pem in data directory. Trying to enable SSL support using them.2000-02-05T02:19:10.762482Z 0 [Note] Skipping generation of SSL certificates as certificate files are present in data directory.服务器安装时服务器时间为2000年，在这个时间下安装启动了MySQL，现在将服务器时间正常同步为2023年，服务器时间差异大，MySQL证书过期导致无法访问\n解决问题\n删除旧证书\n重启MySQL参考Creating SSL and RSA Certificates and Keys using MySQL\n\n","categories":["Data"],"tags":["MySQL","Hibernate"]},{"title":"宽表、窄表、横表、纵表有什么不同","url":"/2023/05/28/what-diffrence-table-structure/","content":"宽表、窄表是大数据中的概念\n宽表，字段比较多的数据库表。将业务主题相关的多个维度的字段关联在一起的一张数据库表。宽表的本质：以空间换时间好处：\n\n统一口径\n降低统计难度，减少表之间的关联\n节省跑数时间\n节省资源\n\n窄表，符合三范式，相同维度的字段组成一张表。表和表之间关联查询。\n横表、纵表横表：也称为行表，将数据按照行进行排列。纵表：也称为列式表或属性表，将数据按照列进行排列。横表\n\n\n\nID\n英语\n数学\n体育\n物理\n\n\n\n\n1\n99\n100\n100\n99\n\n\n\n\n优点：结构清晰，业务逻辑描述清楚；数据量小\n缺点：字段固定，不便于存储；增加字段要改表结构\n\n纵表\n\n\n\nID\n科目/datatype\n成绩/value\n\n\n\n\n1\n英语\n99\n\n\n2\n数学\n100\n\n\n3\n体育\n100\n\n\n4\n物理\n99\n\n\n\n\n优点：可变字段存储容易\n缺点：数据量大；表结构对业务描述不清晰\n\n","categories":["Data"],"tags":["横表","纵表","宽表","窄表","竖表"]},{"title":"C/C++参数中的_In_和_Out_代表什么","url":"/2023/09/28/what-is-In-Out-on-cpp/","content":"最近看方法参数中的疑惑\nsai_status_t sai_api_query(_In_ sai_api_t sai_api_id, _Out_ void** api_method_table)&#123;&#125;\n_In_和_Out_是用于标记参数的传递方式的注解。它们并不是C\\C++语言的关键字，而是一种约定俗成的注释方式，用于提示函数的调用者和阅读者关于参数的特性。\n_In_表示该参数是输入参数，即函数内部会读取参数的值，但不会修改它。通过这个标记，我们可以清楚地知道该参数在函数内部只被用于读取数据。\n_Out_表示该参数是输出参数，即函数内部会修改参数的值，并将修改后的结果返回给调用者。通过这个标记，我们可以清楚地知道该参数在函数内部会被修改，我们在调用函数时需要确认传入的参数具备存储修改后结果的能力。\n\n总结起来，_In_和_Out_这两个标记主要用于提供参数的传递方式的额外信息，帮助理解函数的行为和外部变量的使用。\n上面的**又是什么意思呢？\n&amp;&amp; 和 &amp; 是 C++ 中的运算符， 和 * 是 C++ 中的指针。&amp;&amp; 和 &amp; 表示引用和取地址， 和 * 表示指针的指针和指针。\n&amp;&amp; 和 &amp; 的区别\n\n\n\n特性\n&amp;&amp;\n&amp;\n\n\n\n\n定义\n引用\n取地址\n\n\n用途\n指向变量\n获取变量的地址\n\n\n实现\n可以用来避免值传递造成的副本开销\n可以用来访问变量的值\n\n\n\n* 和  的区别\n\n\n\n特性\n**\n*\n\n\n\n\n定义\n指针的指针\n指针\n\n\n用途\n存储另一个指针的地址\n存储变量的地址\n\n\n实现\n可以用来实现链表、树等数据结构\n可以用来访问变量的值\n\n\n\n示例\nC++\n// &amp;&amp; 和 &amp;int x = 10;int &amp;y = x;int *p = &amp;x;// ** 和 *int *p1 = new int(10);int **pp = &amp;p1;\n请谨慎使用代码。了解详情\ncontent_copy\n在这种情况下，y 是一个引用，它指向变量 x。p 是一个指针，它指向变量 x 的地址。p1 是一个指针，它指向一个整数。pp 是一个指针，它指向一个指针，该指针指向一个整数。\n结论\n&amp;&amp; 和 &amp; 表示引用和取地址，* 和  表示指针的指针和指针。\n总结\n* 和  在 C 和 C++ 中的区别在于：\n\n** 在 C 中表示指针的指针，在 C++ 中表示指针。\n** 在 C 中可以用来存储另一个指针的地址，在 C++ 中可以用来存储变量的地址。\n\n因此，&amp;&amp; 和 &amp; 在 C 和 C++ 中都是可用的，意思也完全相同。* 和  在 C 中也可以使用，但意思与 C++ 中的意思有所不同。\n","categories":["C/C++"],"tags":["_In_","_Out_"]},{"title":"MySQL MGR是什么？","url":"/2024/05/29/what-is-group-replication-in-mysql/","content":"术语\nMGR：MySQL Group Replication，即MySQL组复制\nRPO：Recovery Point Objective恢复点目标\nRTO：Recovery Time Objective恢复时间目标\n\n背景公司核心应用A为公司核心应用，对数据库RPO、RTO都有较高要求。一次数据库主库磁盘expender背板坏了，影响磁盘IO通道，数据库层面出现大面积超时和错误。由于机器未完全坏掉，数据库可以连接，SQL可以执行，导致主从未能自动切换，手动切换时准备脚本，校验数据同步等问题耗时过长，导致公司业务出现重大损失。(原有方案为MHA高可用，半同步复制)由此改为MGR集群技术方案，以期降低主从切换时效，降低损失。\nMGRMGR高可用方案中的RPO、RTORPO：架构模型保障了数据一致性，无需人为干预和检测RTO：因其本身RPO的自动保障，无数据差异，准备耗时短，\nMGR具备以下几个特点：\n基于shared-nothing模式，所有节点都有一份完整数据，发生故障时可以直接切换。MGR提供了数据一致性保障，默认是最终一致性，可根据业务特征需要自行调整一致性级别。支持在线添加、删除节点，节点管理更方便。支持故障自动检测及自动切换，发生故障时能自动切换到新的主节点，再配合MySQL Router中间件，应用层无需干预或调整。支持单节点、多节点写入两种模式，可根据架构或业务需要选择哪种方案，不过强烈建议选用单主模式。\n参考https://dev.mysql.com/doc/refman/8.4/en/group-replication.html\nhttps://greatsql.cn/blog-10-9.html\n","categories":["Data"],"tags":["MGR"]},{"title":"SPI机制","url":"/2024/04/08/what-is-spi/","content":"SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 解耦。SPI整体机制图如下：\n服务提供方提供了接口实现后，需要在classpath下的META-INF/services/目录下创建以服务接口命名的文件，文件内容为接口的实现类名。其他程序使用服务时，会通过查找这个jar的META-INF/services/中文件，获取实现类名，进行加载实例化，该服务就可以使用了。JDK中查找服务实现的类为java.util.ServiceLoader。\n应用-JDBCJDBC接口定义在java中定义了接口java.sql.Driver，并没有实现，具体实现由不通厂商实现。\nMySQL实现MySQL的jar包（mysql-connector-java-8.0.30.jar）中，META-INF/services目录下有文件名java.sql.Driver的内容为com.mysql.cj.jdbc.Driver\n使用方法Connection conn = DriverManager.getConnection(url,username,password);\nSPI如何实现在使用的时候并没有指定使用哪个Driver来连接，那如何使用上MySQL的驱动的呢？这就是我们SPI在起作用。package java.sql;public class DriverManager &#123;    static &#123;        loadInitialDrivers();        println(\"JDBC DriverManager initialized\");    &#125;        private static void loadInitialDrivers() &#123;        String drivers;        try &#123;            drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123;                public String run() &#123;                    return System.getProperty(\"jdbc.drivers\");                &#125;            &#125;);        &#125; catch (Exception ex) &#123;            drivers = null;        &#125;               AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;            public Void run() &#123;                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();                try&#123;                    while(driversIterator.hasNext()) &#123;                        driversIterator.next();                    &#125;                &#125; catch(Throwable t) &#123;                &#125;                return null;            &#125;        &#125;);        println(\"DriverManager.initialize: jdbc.drivers = \" + drivers);        if (drivers == null || drivers.equals(\"\")) &#123;            return;        &#125;        String[] driversList = drivers.split(\":\");        println(\"number of Drivers:\" + driversList.length);        for (String aDriver : driversList) &#123;            try &#123;                println(\"DriverManager.Initialize: loading \" + aDriver);                Class.forName(aDriver, true,                        ClassLoader.getSystemClassLoader());            &#125; catch (Exception ex) &#123;                println(\"DriverManager.Initialize: load failed: \" + ex);            &#125;        &#125;    &#125;&#125;其中ServiceLoader loadedDrivers = ServiceLoader.load(Driver.class);Iterator driversIterator = loadedDrivers.iterator();负责查找classpath下及jar包中META-INF/services目录下java.sql.Driver文件中的内容获取具体实现。\nSPI机制的缺陷通过上面的解析，可以发现，我们使用SPI机制的缺陷：\n\n不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。\n获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。\n多个并发多线程使用 ServiceLoader 类的实例是不安全的.\n\n","categories":["Java"],"tags":["SPI"]},{"title":"如何找出so依赖来源","url":"/2023/03/01/which-lib-refernce-so/","content":"问题上架Google Play时提示引用了有缺陷的OpenSSL版本\n解决思路\n找出该so属于哪个库\n升级或如何排除该so\n\n找出so属于哪个库在app下的build.gradle中添加如下代码//列出所有包含有so文件的库信息tasks.whenTaskAdded &#123; task -&gt;    if (task.name.contains(\"DebugNativeLibs\")) &#123;        task.doFirst &#123;            println(\"------------------- find so files start -------------------\")            it.inputs.files.each &#123; file -&gt;                printDir(new File(file.absolutePath))            &#125;            println(\"------------------- find so files end -------------------\")        &#125;    &#125;&#125;def printDir(File file) &#123;    if (file != null) &#123;        if (file.isDirectory()) &#123;            file.listFiles().each &#123;                printDir(it)            &#125;        &#125; else if (file.absolutePath.endsWith(\".so\")) &#123;            println \"find so file: $file.absolutePath\"        &#125;    &#125;&#125;在build执行mergeFlavorDebugNativeLibs时即会打印出引用的所so库Github中搜索该库是否有修正新的OpenSSL版本发现该库最新版仍然引用错误的OpenSSL版本，且没有再维护。\n排除三方库中的so我们知道在packagingOptions中可以排除库以及同名库时选择采用哪个库exclude、pickFirst、doNotStrip、merge查看发现exclude并不能排除aar、lib中的so，所以只能看引用的库是否能升级，否则考虑是否引用该库。另外在保证功能正常使用的情况下，加入同名so，采用pickFirst的方式引用我们想引用的so\n参考gradle配置项packagingOptions使用说明Gradle 提示与诀窍【Gradle实战】利用Gradle查找项目里的so库来源\n","categories":["Android"],"tags":["so","有缺陷的OpenSSL版本","DebugNativeLibs"]},{"title":"FTP传输到底用的哪个端口","url":"/2023/06/30/which-port-is-used-to-data-transmission-by-ftp/","content":"问题最近使用Docker搭建FTP后，客户端可以连接无法列出目录，无法上传。通常我们认为FTP占用端口21用于传输控制命令，20传输数据。而我的21、20端口都有映射、开放。\n环境\nDocker (24.0.2, build cb74dfc)\nApache FtpServer (1.0.0)\n\n原因分析FileZilla连接效果如下\n\n\n对应FtpServer的日志如下\n\n根据上面信息看到前面的控制命令都正常工作，直到FtpServer收到”MLSD”时，出现异常\nMLSD：获取远程服务器上的文件和目录列表（Machine List Directory）\n此时，连接为PASV（被动模式），FtpServer使用端口26037与客户端连接传输数据\n而26037端口并未对外开放，我们以为的只有21、20，26037又是怎么来的，在哪里配置的呢？\n原来FTP分为PORT(主动模式)和PASV(被动模式)\nFTP主动模式和被动模式以下内容来源于ChatGPT\n\n主动模式\n在主动模式中，客户端首先建立一个控制连接（Control Connection）到服务器的FTP控制端口（默认为21）。当需要进行数据传输时，客户端会随机选择一个高位端口（大于1023）作为数据端口，并将该端口号发送给服务器。服务器会通过控制连接告知客户端它将使用的数据端口（服务器端口）。然后，客户端会主动连接服务器的数据端口，以进行数据传输。\n\n被动模式\n在被动模式中，客户端首先建立一个控制连接到服务器的FTP控制端口（默认为21）。当需要进行数据传输时，服务器会随机选择一个高位端口（1024-65535）作为数据端口，并将该端口号发送给客户端。然后，客户端会通过控制连接告知服务器它将使用的数据端口（客户端端口）。服务器会主动连接客户端的数据端口，以进行数据传输。\n\n\n主动模式和被动模式的区别在于数据连接的建立方式。在主动模式中，客户端主动连接服务器的数据端口，而在被动模式中，服务器主动连接客户端的数据端口。\n使用主动模式时，客户端需要打开一个高位端口用于数据连接，这可能会导致防火墙或网络设备的配置问题。而使用被动模式时，服务器打开一个高位端口用于数据连接，这样更容易通过防火墙和网络设备。\n需要注意的是，FTP协议已经有一些安全性和性能问题，因此在实际应用中，往往会使用更安全和高效的替代协议，如SFTP（SSH File Transfer Protocol）或FTPS（FTP over SSL/TLS）。\n附图\n\n\n解决问题了解到FTP主动模式、被动模式后，我们选择的是修改被动模式，因为我们无法干涉客户端的环境，客户端随机端口被防火墙拦截，我们无法处理。但被动模式下1024-65535的端口范围太大，我们不希望FtpServer开放这么多端口，那如何自定义修改呢？\n修改FtpServer被动模式端口修改FtpServer的ftpd-typical.xml\n\n修改后端口范围为12200-12202，再开放映射端口后，就可以正常工作了\nNotice：\nWhen the client wants to use a passive data connection, the server should provide the port to use. By default, FtpServer will choose any available port. However this can be overridden using the configuration for the passive data connection. When the server has used up all passive ports (one per client doing passive data transfer), the next clients will have to wait for an available port. It is therefore advised to provide multiple passive ports.\nConfigure passive ports\n是否需要根据并发来考虑端口范围呢？\n其中tcpdump作用太大，得精研一下\n参考FTP的主动模式和被动模式详解\nFILE TRANSFER PROTOCOL\nFirewall-Friendly FTP\n","categories":["Java"],"tags":["FTP","EPASV"]},{"title":"内存没满但是频繁fullgc，是不是ReservedCodeCacheSize的锅","url":"/2023/09/03/why-the-memory-not-full-but-frequently-fullgc/","content":"业务中的现象表现运行一段时间后，频繁fullgc，2s10几次fullgc，无法对外提供服务\n环境gc日志内存还有非常多的情况下就开始了fullgc\ndump分析只看到class loader的一直重新加载？内存指向java.security.Permission，没有其他大对象？没有搞懂重新改好了也是这样，需要再搞懂\njvm参数-Xms128m -Xmx256m -XX:ReservedCodeCacheSize=50m -XX:MetaspaceSize=96m -XX:MaxMetaspaceSize=96m -Xss256k -XX:MaxDirectMemorySize=16m-XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSClassUnloadingEnabled-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:GCLogFileSize=10M -XX:NumberOfGCLogFiles=3 -Xloggc:/var/logs/gc1.log-XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:NativeMemoryTracking=summary-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/var/logs/dump1-$(date +%Y%m%d%H%M%S).hprof\"\n修改怀疑是-XX:ReservedCodeCacheSize=50m导致Meta不生效，导致重新加载fullgc?\n修改为jvm参数，后好使了\n-Xms128m -Xmx256m -XX:PermSize=128m -XX:-UseGCOverheadLimit -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:GCLogFileSize=10M -XX:NumberOfGCLogFiles=3 -Xloggc:/var/logs/gc1.log-XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:NativeMemoryTracking=summary-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/var/logs/dump1-$(date +%Y%m%d%H%M%S).hprof\"\n需要再研究，怎么来指向这个问题。\n另外火焰图必不可少\n","categories":["Java"],"tags":["fullgc"]}]